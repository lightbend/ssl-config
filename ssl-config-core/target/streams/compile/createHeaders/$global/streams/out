[0m[[0mdebug[0m] [0mAbout to create/update header for /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/MonkeyPatcher.scala[0m
[0m[[0mdebug[0m] [0mFirst line of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/MonkeyPatcher.scala is:[0m
[0m[[0mdebug[0m] [0mText of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/MonkeyPatcher.scala is:[0m
[0m[[0mdebug[0m] [0m/*[0m
[0m[[0mdebug[0m] [0m * Copyright (C) 2015 Typesafe Inc. <http://www.typesafe.com>[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mpackage com.typesafe.sslconfig.ssl[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport java.lang.reflect.Field[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0mtrait MonkeyPatcher {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  // Define unsafe to monkeypatch fields[0m
[0m[[0mdebug[0m] [0m  private val unsafe: sun.misc.Unsafe = {[0m
[0m[[0mdebug[0m] [0m    val field = Class.forName("sun.misc.Unsafe").getDeclaredField("theUnsafe")[0m
[0m[[0mdebug[0m] [0m    field.setAccessible(true)[0m
[0m[[0mdebug[0m] [0m    field.get(null).asInstanceOf[sun.misc.Unsafe][0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Monkeypatches any given field.[0m
[0m[[0mdebug[0m] [0m   *[0m
[0m[[0mdebug[0m] [0m   * @param field the field to change[0m
[0m[[0mdebug[0m] [0m   * @param newObject the new object to place in the field.[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def monkeyPatchField(field: Field, newObject: AnyRef) {[0m
[0m[[0mdebug[0m] [0m    val base = unsafe.staticFieldBase(field)[0m
[0m[[0mdebug[0m] [0m    val offset = unsafe.staticFieldOffset(field)[0m
[0m[[0mdebug[0m] [0m    unsafe.putObject(base, offset, newObject)[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mModified text of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/MonkeyPatcher.scala is:[0m
[0m[[0mdebug[0m] [0mNone[0m
[0m[[0mdebug[0m] [0mAbout to create/update header for /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/KeyStore.scala[0m
[0m[[0mdebug[0m] [0mFirst line of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/KeyStore.scala is:[0m
[0m[[0mdebug[0m] [0mText of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/KeyStore.scala is:[0m
[0m[[0mdebug[0m] [0m/*[0m
[0m[[0mdebug[0m] [0m * Copyright (C) 2015 Typesafe Inc. <http://www.typesafe.com>[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mpackage com.typesafe.sslconfig.ssl[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport java.security.KeyStore[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport java.io._[0m
[0m[[0mdebug[0m] [0mimport java.security.cert._[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport com.typesafe.sslconfig.util.NoDepsLogger[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mtrait KeyStoreBuilder {[0m
[0m[[0mdebug[0m] [0m  def build(): KeyStore[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mobject KeystoreFormats {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def loadCertificates(certs: TraversableOnce[Certificate]): KeyStore = {[0m
[0m[[0mdebug[0m] [0m    // Must be JKS internally, to enable trusted certificates in JDK 1.6[0m
[0m[[0mdebug[0m] [0m    val keystore = KeyStore.getInstance(KeyStore.getDefaultType)[0m
[0m[[0mdebug[0m] [0m    keystore.load(null)[0m
[0m[[0mdebug[0m] [0m    certs.foreach { cert =>[0m
[0m[[0mdebug[0m] [0m      val alias = cert.getSubjectX500Principal.getName[0m
[0m[[0mdebug[0m] [0m      keystore.setCertificateEntry(alias, cert)[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m    keystore[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport KeystoreFormats._[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * Builds a keystore from a string containing PEM encoded certificates, using CertificateFactory internally.[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * @see java.security.cert.CertificateFactory[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0mclass StringBasedKeyStoreBuilder(data: String) extends KeyStoreBuilder {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def build(): KeyStore = {[0m
[0m[[0mdebug[0m] [0m    val certs = readCertificates(data)[0m
[0m[[0mdebug[0m] [0m    val store = loadCertificates(certs)[0m
[0m[[0mdebug[0m] [0m    store[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def readCertificates(certificateString: String): Seq[Certificate] = {[0m
[0m[[0mdebug[0m] [0m    val cf = CertificateFactory.getInstance("X.509")[0m
[0m[[0mdebug[0m] [0m    // CertificateFactory throws EOF on whitespace after end cert, which is very common in triple quoted strings.[0m
[0m[[0mdebug[0m] [0m    val trimmedString = certificateString.trim()[0m
[0m[[0mdebug[0m] [0m    val is = new ByteArrayInputStream(trimmedString.getBytes("UTF-8"))[0m
[0m[[0mdebug[0m] [0m    val bis = new BufferedInputStream(is)[0m
[0m[[0mdebug[0m] [0m    val buffer = new scala.collection.mutable.ListBuffer[Certificate]()[0m
[0m[[0mdebug[0m] [0m    while (bis.available() > 0) {[0m
[0m[[0mdebug[0m] [0m      val cert = cf.generateCertificate(bis)[0m
[0m[[0mdebug[0m] [0m      buffer.append(cert)[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m    buffer.toList[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * Builds a keystore from a file containing PEM encoded certificates, using CertificateFactory internally.[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * @see java.security.cert.CertificateFactory[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0mclass FileBasedKeyStoreBuilder(keyStoreType: String,[0m
[0m[[0mdebug[0m] [0m                               filePath: String,[0m
[0m[[0mdebug[0m] [0m                               password: Option[Array[Char]]) extends KeyStoreBuilder {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def build(): KeyStore = {[0m
[0m[[0mdebug[0m] [0m    val file = new File(filePath)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    require(file.exists, s"Key store file $filePath does not exist!")[0m
[0m[[0mdebug[0m] [0m    require(file.canRead, s"Cannot read from key store file $filePath!")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    keyStoreType match {[0m
[0m[[0mdebug[0m] [0m      case "PEM" =>[0m
[0m[[0mdebug[0m] [0m        val certs = readCertificates(file)[0m
[0m[[0mdebug[0m] [0m        loadCertificates(certs)[0m
[0m[[0mdebug[0m] [0m      case otherFormat =>[0m
[0m[[0mdebug[0m] [0m        buildFromKeystoreFile(otherFormat, file)[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def buildFromKeystoreFile(storeType: String, file: File): KeyStore = {[0m
[0m[[0mdebug[0m] [0m    val inputStream = new BufferedInputStream(new FileInputStream(file))[0m
[0m[[0mdebug[0m] [0m    try {[0m
[0m[[0mdebug[0m] [0m      val storeType = keyStoreType[0m
[0m[[0mdebug[0m] [0m      val store = KeyStore.getInstance(storeType)[0m
[0m[[0mdebug[0m] [0m      store.load(inputStream, password.orNull)[0m
[0m[[0mdebug[0m] [0m      store[0m
[0m[[0mdebug[0m] [0m    } finally {[0m
[0m[[0mdebug[0m] [0m      inputStream.close()[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def readCertificates(file: File): Iterable[Certificate] = {[0m
[0m[[0mdebug[0m] [0m    import scala.collection.JavaConverters._[0m
[0m[[0mdebug[0m] [0m    val cf = CertificateFactory.getInstance("X.509")[0m
[0m[[0mdebug[0m] [0m    val fis = new FileInputStream(file)[0m
[0m[[0mdebug[0m] [0m    val bis = new BufferedInputStream(fis)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    cf.generateCertificates(bis).asScala[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mclass FileOnClasspathBasedKeyStoreBuilder(keyStoreType: String,[0m
[0m[[0mdebug[0m] [0m                                          filePath: String,[0m
[0m[[0mdebug[0m] [0m                                          password: Option[Array[Char]]) extends KeyStoreBuilder {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def build(): KeyStore = {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val is = getClass.getClassLoader.getResourceAsStream(filePath)[0m
[0m[[0mdebug[0m] [0m    require(is != null, s"Key store file $filePath was not found on the class path!")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    keyStoreType match {[0m
[0m[[0mdebug[0m] [0m      case "PEM" =>[0m
[0m[[0mdebug[0m] [0m        val certs = readCertificates(is)[0m
[0m[[0mdebug[0m] [0m        loadCertificates(certs)[0m
[0m[[0mdebug[0m] [0m      case otherFormat =>[0m
[0m[[0mdebug[0m] [0m        buildFromKeystoreFile(otherFormat, is)[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def buildFromKeystoreFile(storeType: String, is: InputStream): KeyStore = {[0m
[0m[[0mdebug[0m] [0m    val inputStream = new BufferedInputStream(is)[0m
[0m[[0mdebug[0m] [0m    try {[0m
[0m[[0mdebug[0m] [0m      val storeType = keyStoreType[0m
[0m[[0mdebug[0m] [0m      val store = KeyStore.getInstance(storeType)[0m
[0m[[0mdebug[0m] [0m      store.load(inputStream, password.orNull)[0m
[0m[[0mdebug[0m] [0m      store[0m
[0m[[0mdebug[0m] [0m    } finally {[0m
[0m[[0mdebug[0m] [0m      inputStream.close()[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def readCertificates(is: InputStream): Iterable[Certificate] = {[0m
[0m[[0mdebug[0m] [0m    import scala.collection.JavaConverters._[0m
[0m[[0mdebug[0m] [0m    val cf = CertificateFactory.getInstance("X.509")[0m
[0m[[0mdebug[0m] [0m    val bis = new BufferedInputStream(is)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    cf.generateCertificates(bis).asScala[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mModified text of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/KeyStore.scala is:[0m
[0m[[0mdebug[0m] [0mNone[0m
[0m[[0mdebug[0m] [0mAbout to create/update header for /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/DefaultHostnameVerifier.scala[0m
[0m[[0mdebug[0m] [0mFirst line of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/DefaultHostnameVerifier.scala is:[0m
[0m[[0mdebug[0m] [0mText of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/DefaultHostnameVerifier.scala is:[0m
[0m[[0mdebug[0m] [0m/*[0m
[0m[[0mdebug[0m] [0m * Copyright (C) 2015 Typesafe Inc. <http://www.typesafe.com>[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mpackage com.typesafe.sslconfig.ssl[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport java.security.cert.{ Certificate, CertificateException, X509Certificate }[0m
[0m[[0mdebug[0m] [0mimport javax.net.ssl.{ HostnameVerifier, SSLPeerUnverifiedException, SSLSession }[0m
[0m[[0mdebug[0m] [0mimport javax.security.auth.kerberos.KerberosPrincipal[0m
[0m[[0mdebug[0m] [0mimport com.typesafe.sslconfig.Base64[0m
[0m[[0mdebug[0m] [0mimport com.typesafe.sslconfig.util.{ LoggerFactory, NoDepsLogger }[0m
[0m[[0mdebug[0m] [0mimport sun.security.util.HostnameChecker[0m
[0m[[0mdebug[0m] [0mimport java.security.Principal[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * Use the internal sun hostname checker as the hostname verifier. Thanks to Kevin Locke.[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * @see sun.security.util.HostnameChecker[0m
[0m[[0mdebug[0m] [0m * @see http://kevinlocke.name/bits/2012/10/03/ssl-certificate-verification-in-dispatch-and-asynchttpclient/[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0mclass DefaultHostnameVerifier(mkLogger: LoggerFactory) extends HostnameVerifier {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  // AsyncHttpClient issue #197: "SSL host name verification disabled by default"[0m
[0m[[0mdebug[0m] [0m  // https://github.com/AsyncHttpClient/async-http-client/issues/197[0m
[0m[[0mdebug[0m] [0m  //[0m
[0m[[0mdebug[0m] [0m  // From http://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/JSSERefGuide.html#HostnameVerifier[0m
[0m[[0mdebug[0m] [0m  //[0m
[0m[[0mdebug[0m] [0m  // "When using raw SSLSockets/SSLEngines you should always check the peer's credentials before sending any data.[0m
[0m[[0mdebug[0m] [0m  // The SSLSocket and SSLEngine classes do not automatically verify that the hostname in a URL matches the[0m
[0m[[0mdebug[0m] [0m  // hostname in the peer's credentials. An application could be exploited with URL spoofing if the hostname is[0m
[0m[[0mdebug[0m] [0m  // not verified."[0m
[0m[[0mdebug[0m] [0m  //[0m
[0m[[0mdebug[0m] [0m  // We are using SSLEngine directly, so we have to use the AsyncHttpClient Netty Provider to provide hostnname[0m
[0m[[0mdebug[0m] [0m  // verification.[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  private val logger = mkLogger(getClass)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def hostnameChecker: HostnameChecker = HostnameChecker.getInstance(HostnameChecker.TYPE_TLS)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def matchKerberos(hostname: String, principal: Principal) = HostnameChecker.`match`(hostname, principal.asInstanceOf[KerberosPrincipal])[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def isKerberos(principal: Principal): Boolean = principal != null && principal.isInstanceOf[KerberosPrincipal][0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def verify(hostname: String, session: SSLSession): Boolean = {[0m
[0m[[0mdebug[0m] [0m    val base64 = Base64.rfc2045()[0m
[0m[[0mdebug[0m] [0m    logger.debug(s"verify: hostname = $hostname, sessionId (base64) = ${base64.encodeToString(session.getId, false)}")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val result = try {[0m
[0m[[0mdebug[0m] [0m      val peerCertificates = session.getPeerCertificates[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m      matchCertificates(hostname, peerCertificates)[0m
[0m[[0mdebug[0m] [0m    } catch {[0m
[0m[[0mdebug[0m] [0m      case _: SSLPeerUnverifiedException =>[0m
[0m[[0mdebug[0m] [0m        // Not using certificates for verification, try verifying the principal[0m
[0m[[0mdebug[0m] [0m        try {[0m
[0m[[0mdebug[0m] [0m          val principal = session.getPeerPrincipal[0m
[0m[[0mdebug[0m] [0m          if (isKerberos(principal)) {[0m
[0m[[0mdebug[0m] [0m            matchKerberos(hostname, principal)[0m
[0m[[0mdebug[0m] [0m          } else {[0m
[0m[[0mdebug[0m] [0m            // Can't verify principal, not Kerberos[0m
[0m[[0mdebug[0m] [0m            logger.debug(s"verify: Can't verify principal, not Kerberos")[0m
[0m[[0mdebug[0m] [0m            false[0m
[0m[[0mdebug[0m] [0m          }[0m
[0m[[0mdebug[0m] [0m        } catch {[0m
[0m[[0mdebug[0m] [0m          case e: SSLPeerUnverifiedException =>[0m
[0m[[0mdebug[0m] [0m            // Can't verify principal, no principal[0m
[0m[[0mdebug[0m] [0m            logger.debug(s"Can't verify principal, no principal. Cause: $e")[0m
[0m[[0mdebug[0m] [0m            false[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m    logger.debug(s"verify: returning $result")[0m
[0m[[0mdebug[0m] [0m    result[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /** INTERNAL API */[0m
[0m[[0mdebug[0m] [0m  def matchCertificates(hostname: String, peerCertificates: Array[Certificate]): Boolean = {[0m
[0m[[0mdebug[0m] [0m    val checker = hostnameChecker[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    peerCertificates match {[0m
[0m[[0mdebug[0m] [0m      case Array(cert: X509Certificate, _*) =>[0m
[0m[[0mdebug[0m] [0m        try {[0m
[0m[[0mdebug[0m] [0m          checker.`match`(hostname, cert)[0m
[0m[[0mdebug[0m] [0m          // Certificate matches hostname[0m
[0m[[0mdebug[0m] [0m          true[0m
[0m[[0mdebug[0m] [0m        } catch {[0m
[0m[[0mdebug[0m] [0m          case e: CertificateException =>[0m
[0m[[0mdebug[0m] [0m            // Certificate does not match hostname[0m
[0m[[0mdebug[0m] [0m            val subjectAltNames = cert.getSubjectAlternativeNames[0m
[0m[[0mdebug[0m] [0m            logger.debug(s"verify: Certificate does not match hostname! subjectAltNames = $subjectAltNames, hostName = $hostname Cause: $e")[0m
[0m[[0mdebug[0m] [0m            false[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m      case notMatch =>[0m
[0m[[0mdebug[0m] [0m        // Peer does not have any certificates or they aren't X.509[0m
[0m[[0mdebug[0m] [0m        logger.debug(s"verify: Peer does not have any certificates: $notMatch")[0m
[0m[[0mdebug[0m] [0m        false[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mModified text of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/DefaultHostnameVerifier.scala is:[0m
[0m[[0mdebug[0m] [0mNone[0m
[0m[[0mdebug[0m] [0mAbout to create/update header for /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/Config.scala[0m
[0m[[0mdebug[0m] [0mFirst line of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/Config.scala is:[0m
[0m[[0mdebug[0m] [0mText of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/Config.scala is:[0m
[0m[[0mdebug[0m] [0m/*[0m
[0m[[0mdebug[0m] [0m * Copyright (C) 2015 Typesafe Inc. <http://www.typesafe.com>[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mpackage com.typesafe.sslconfig.ssl[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport java.net.URL[0m
[0m[[0mdebug[0m] [0mimport java.security.{KeyStore, SecureRandom}[0m
[0m[[0mdebug[0m] [0mimport java.util.Optional[0m
[0m[[0mdebug[0m] [0mimport javax.net.ssl.{HostnameVerifier, KeyManagerFactory, SSLParameters, TrustManagerFactory}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport scala.collection.immutable[0m
[0m[[0mdebug[0m] [0mimport com.typesafe.config.Config[0m
[0m[[0mdebug[0m] [0mimport com.typesafe.sslconfig.util.EnrichedConfig[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport scala.language.existentials[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * Configuration for a keystore.[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * A key store must either provide a file path, or a data String.[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * Either key store path or data must be defined, but not both.[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * @param storeType The store type. Defaults to the platform default store type (ie, JKS).[0m
[0m[[0mdebug[0m] [0m * @param filePath The path of the key store file.[0m
[0m[[0mdebug[0m] [0m * @param data The data to load the key store file from.[0m
[0m[[0mdebug[0m] [0m * @param password The password to use to load the key store file, if the file is password protected.[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0mfinal class KeyStoreConfig private[sslconfig]([0m
[0m[[0mdebug[0m] [0m  val data: Option[String],[0m
[0m[[0mdebug[0m] [0m  val filePath: Option[String],[0m
[0m[[0mdebug[0m] [0m  val isFileOnClasspath: Boolean = false,[0m
[0m[[0mdebug[0m] [0m  val password: Option[String] = None,[0m
[0m[[0mdebug[0m] [0m  val storeType: String = KeyStore.getDefaultType) {[0m
[0m[[0mdebug[0m] [0m  assert(filePath.isDefined ^ data.isDefined, "Either key store path or data must be defined, but not both.")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /** Disables `filePath` â€“ only one of those can be used at any given time. */[0m
[0m[[0mdebug[0m] [0m  def withData(data: Option[String]): KeyStoreConfig = copy(data = data, filePath = None)[0m
[0m[[0mdebug[0m] [0m  /** Disables `data` â€“ only one of those can be used at any given time. */[0m
[0m[[0mdebug[0m] [0m  def withFilePath(filePath: Option[String]): KeyStoreConfig = copy(filePath = filePath, data = None)[0m
[0m[[0mdebug[0m] [0m  def withFileOnClassPath(isFileOnClasspath: Boolean): KeyStoreConfig = copy(isFileOnClasspath = isFileOnClasspath, data = None)[0m
[0m[[0mdebug[0m] [0m  def withPassword(value: Option[String]): KeyStoreConfig = copy(password = value)[0m
[0m[[0mdebug[0m] [0m  def withStoreType(value: String): KeyStoreConfig = copy(storeType = value)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  private def copy([0m
[0m[[0mdebug[0m] [0m    data: Option[String] = data,[0m
[0m[[0mdebug[0m] [0m    filePath: Option[String] = filePath,[0m
[0m[[0mdebug[0m] [0m    isFileOnClasspath: Boolean = isFileOnClasspath,[0m
[0m[[0mdebug[0m] [0m    password: Option[String] = password,[0m
[0m[[0mdebug[0m] [0m    storeType: String = storeType): KeyStoreConfig = new KeyStoreConfig([0m
[0m[[0mdebug[0m] [0m      data = data,[0m
[0m[[0mdebug[0m] [0m      filePath = filePath,[0m
[0m[[0mdebug[0m] [0m      isFileOnClasspath = isFileOnClasspath,[0m
[0m[[0mdebug[0m] [0m      password = password,[0m
[0m[[0mdebug[0m] [0m      storeType = storeType)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  override def toString =[0m
[0m[[0mdebug[0m] [0m    s"""KeyStoreConfig(${data},${filePath},${isFileOnClasspath},${password},${storeType})"""[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mobject KeyStoreConfig {[0m
[0m[[0mdebug[0m] [0m  def apply(data: Option[String], filePath: Option[String]) = new KeyStoreConfig(data, filePath)[0m
[0m[[0mdebug[0m] [0m  /** Java API */[0m
[0m[[0mdebug[0m] [0m  def getInstance(data: Optional[String], filePath: Optional[String]) =[0m
[0m[[0mdebug[0m] [0m    apply(Option(data.orElse(null)), Option(filePath.orElse(null)))[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * The trust manager config.[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * @param algorithm The algorithm to use.[0m
[0m[[0mdebug[0m] [0m * @param trustStoreConfigs The trust stores to use.[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0mfinal class TrustManagerConfig private[sslconfig]([0m
[0m[[0mdebug[0m] [0m  val algorithm: String = TrustManagerFactory.getDefaultAlgorithm,[0m
[0m[[0mdebug[0m] [0m  val trustStoreConfigs: immutable.Seq[TrustStoreConfig] = Nil) {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def withAlgorithm(value: String): TrustManagerConfig = copy(algorithm = value)[0m
[0m[[0mdebug[0m] [0m  def withTrustStoreConfigs(value: scala.collection.immutable.Seq[com.typesafe.sslconfig.ssl.TrustStoreConfig]): TrustManagerConfig = copy(trustStoreConfigs = value)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  private def copy([0m
[0m[[0mdebug[0m] [0m    algorithm: String = algorithm,[0m
[0m[[0mdebug[0m] [0m    trustStoreConfigs: scala.collection.immutable.Seq[com.typesafe.sslconfig.ssl.TrustStoreConfig] = trustStoreConfigs): TrustManagerConfig = new TrustManagerConfig([0m
[0m[[0mdebug[0m] [0m      algorithm = algorithm,[0m
[0m[[0mdebug[0m] [0m      trustStoreConfigs = trustStoreConfigs)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  override def toString =[0m
[0m[[0mdebug[0m] [0m    s"""TrustManagerConfig(${algorithm},${trustStoreConfigs})"""[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mobject TrustManagerConfig {[0m
[0m[[0mdebug[0m] [0m  def apply() = new TrustManagerConfig()[0m
[0m[[0mdebug[0m] [0m  /** Java API */[0m
[0m[[0mdebug[0m] [0m  def getInstance() = apply()[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * Configuration for a trust store.[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * A trust store must either provide a file path, or a data String.[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * @param storeType The store type. Defaults to the platform default store type (ie, JKS).[0m
[0m[[0mdebug[0m] [0m * @param filePath The path of the key store file.[0m
[0m[[0mdebug[0m] [0m * @param data The data to load the key store file from.[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0mfinal class TrustStoreConfig private[sslconfig]([0m
[0m[[0mdebug[0m] [0m  val data: Option[String],[0m
[0m[[0mdebug[0m] [0m  val filePath: Option[String],[0m
[0m[[0mdebug[0m] [0m  val isFileOnClasspath: Boolean = false,[0m
[0m[[0mdebug[0m] [0m  val storeType: String = KeyStore.getDefaultType) {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  assert(filePath.isDefined ^ data.isDefined, "Either trust store path or data must be defined, but not both.")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /** Disables `filePath` â€“ only one of those can be used at any given time. */[0m
[0m[[0mdebug[0m] [0m  def withData(data: Option[String]): TrustStoreConfig = copy(data = data, filePath = None)[0m
[0m[[0mdebug[0m] [0m  /** Disables `data` â€“ only one of those can be used at any given time. */[0m
[0m[[0mdebug[0m] [0m  def withFilePath(filePath: Option[String]): TrustStoreConfig = copy(filePath = filePath, data = None)[0m
[0m[[0mdebug[0m] [0m  def withFileOnClasspath(isFileOnClasspath: Boolean): TrustStoreConfig = copy(isFileOnClasspath = isFileOnClasspath, data = None)[0m
[0m[[0mdebug[0m] [0m  def withStoreType(value: String): TrustStoreConfig = copy(storeType = value)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  private def copy([0m
[0m[[0mdebug[0m] [0m    data: Option[String] = data,[0m
[0m[[0mdebug[0m] [0m    filePath: Option[String] = filePath,[0m
[0m[[0mdebug[0m] [0m    isFileOnClasspath: Boolean = isFileOnClasspath,[0m
[0m[[0mdebug[0m] [0m    storeType: String = storeType): TrustStoreConfig = new TrustStoreConfig([0m
[0m[[0mdebug[0m] [0m      data = data,[0m
[0m[[0mdebug[0m] [0m      filePath = filePath,[0m
[0m[[0mdebug[0m] [0m      isFileOnClasspath = isFileOnClasspath,[0m
[0m[[0mdebug[0m] [0m      storeType = storeType)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  override def toString =[0m
[0m[[0mdebug[0m] [0m    s"""TrustStoreConfig(${data},${filePath},${isFileOnClasspath},${storeType})"""[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mobject TrustStoreConfig {[0m
[0m[[0mdebug[0m] [0m  def apply(data: Option[String], filePath: Option[String]) = new TrustStoreConfig(data, filePath)[0m
[0m[[0mdebug[0m] [0m  /** Java API */[0m
[0m[[0mdebug[0m] [0m  def getInstance(data: Optional[String], filePath: Optional[String]) =[0m
[0m[[0mdebug[0m] [0m    apply(Option(data.orElse(null)), Option(filePath.orElse(null)))[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * The key manager config.[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * @param algorithm The algoritm to use.[0m
[0m[[0mdebug[0m] [0m * @param keyStoreConfigs The key stores to use.[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0mfinal class KeyManagerConfig private[sslconfig]([0m
[0m[[0mdebug[0m] [0m  val algorithm: String = KeyManagerFactory.getDefaultAlgorithm,[0m
[0m[[0mdebug[0m] [0m  val keyStoreConfigs: immutable.Seq[KeyStoreConfig] = Nil) {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def withAlgorithm(value: String): KeyManagerConfig = copy(algorithm = value)[0m
[0m[[0mdebug[0m] [0m  def withKeyStoreConfigs(value: scala.collection.immutable.Seq[com.typesafe.sslconfig.ssl.KeyStoreConfig]): KeyManagerConfig = copy(keyStoreConfigs = value)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  private def copy([0m
[0m[[0mdebug[0m] [0m    algorithm: String = algorithm,[0m
[0m[[0mdebug[0m] [0m    keyStoreConfigs: scala.collection.immutable.Seq[com.typesafe.sslconfig.ssl.KeyStoreConfig] = keyStoreConfigs): KeyManagerConfig = new KeyManagerConfig([0m
[0m[[0mdebug[0m] [0m      algorithm = algorithm,[0m
[0m[[0mdebug[0m] [0m      keyStoreConfigs = keyStoreConfigs)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  override def toString =[0m
[0m[[0mdebug[0m] [0m    s"""KeyManagerConfig(${algorithm},${keyStoreConfigs})"""[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mobject KeyManagerConfig {[0m
[0m[[0mdebug[0m] [0m  def apply() = new KeyManagerConfig()[0m
[0m[[0mdebug[0m] [0m  /** Java API */[0m
[0m[[0mdebug[0m] [0m  def getInstance() = apply()[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * SSL debug configuration.[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0mfinal class SSLDebugConfig private[sslconfig]([0m
[0m[[0mdebug[0m] [0m  val all: Boolean = false,[0m
[0m[[0mdebug[0m] [0m  val certpath: Boolean = false,[0m
[0m[[0mdebug[0m] [0m  val defaultctx: Boolean = false,[0m
[0m[[0mdebug[0m] [0m  val handshake: Option[com.typesafe.sslconfig.ssl.SSLDebugHandshakeOptions] = None,[0m
[0m[[0mdebug[0m] [0m  val keygen: Boolean = false,[0m
[0m[[0mdebug[0m] [0m  val keymanager: Boolean = false,[0m
[0m[[0mdebug[0m] [0m  val ocsp: Boolean = false,[0m
[0m[[0mdebug[0m] [0m  val pluggability: Boolean = false,[0m
[0m[[0mdebug[0m] [0m  val record: Option[com.typesafe.sslconfig.ssl.SSLDebugRecordOptions] = None,[0m
[0m[[0mdebug[0m] [0m  val session: Boolean = false,[0m
[0m[[0mdebug[0m] [0m  val sessioncache: Boolean = false,[0m
[0m[[0mdebug[0m] [0m  val ssl: Boolean = false,[0m
[0m[[0mdebug[0m] [0m  val sslctx: Boolean = false,[0m
[0m[[0mdebug[0m] [0m  val trustmanager: Boolean = false) {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Whether any debug options are enabled.[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def enabled = all || ssl || certpath || ocsp || record.isDefined || handshake.isDefined ||[0m
[0m[[0mdebug[0m] [0m    keygen || session || defaultctx || sslctx || sessioncache || keymanager || trustmanager ||[0m
[0m[[0mdebug[0m] [0m    pluggability[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def withAll(value: Boolean): SSLDebugConfig = copy(all = value)[0m
[0m[[0mdebug[0m] [0m  def withCertPath(value: Boolean): SSLDebugConfig = copy(certpath = value)[0m
[0m[[0mdebug[0m] [0m  def withDefaultContext(value: Boolean): SSLDebugConfig = copy(defaultctx = value)[0m
[0m[[0mdebug[0m] [0m  def withHandshake(value: Option[com.typesafe.sslconfig.ssl.SSLDebugHandshakeOptions]): SSLDebugConfig = copy(handshake = value)[0m
[0m[[0mdebug[0m] [0m  def withKeygen(value: Boolean): SSLDebugConfig = copy(keygen = value)[0m
[0m[[0mdebug[0m] [0m  def withKeymanager(value: Boolean): SSLDebugConfig = copy(keymanager = value)[0m
[0m[[0mdebug[0m] [0m  def withOcsp(value: Boolean): SSLDebugConfig = copy(ocsp = value)[0m
[0m[[0mdebug[0m] [0m  def withPluggability(value: Boolean): SSLDebugConfig = copy(pluggability = value)[0m
[0m[[0mdebug[0m] [0m  def withRecord(value: Option[com.typesafe.sslconfig.ssl.SSLDebugRecordOptions]): SSLDebugConfig = copy(record = value)[0m
[0m[[0mdebug[0m] [0m  def withSession(value: Boolean): SSLDebugConfig = copy(session = value)[0m
[0m[[0mdebug[0m] [0m  def withSessioncache(value: Boolean): SSLDebugConfig = copy(sessioncache = value)[0m
[0m[[0mdebug[0m] [0m  def withSsl(value: Boolean): SSLDebugConfig = copy(ssl = value)[0m
[0m[[0mdebug[0m] [0m  def withSslctx(value: Boolean): SSLDebugConfig = copy(sslctx = value)[0m
[0m[[0mdebug[0m] [0m  def withTrustmanager(value: Boolean): SSLDebugConfig = copy(trustmanager = value)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  private def copy([0m
[0m[[0mdebug[0m] [0m    all: Boolean = all,[0m
[0m[[0mdebug[0m] [0m    certpath: Boolean = certpath,[0m
[0m[[0mdebug[0m] [0m    defaultctx: Boolean = defaultctx,[0m
[0m[[0mdebug[0m] [0m    handshake: Option[com.typesafe.sslconfig.ssl.SSLDebugHandshakeOptions] = handshake,[0m
[0m[[0mdebug[0m] [0m    keygen: Boolean = keygen,[0m
[0m[[0mdebug[0m] [0m    keymanager: Boolean = keymanager,[0m
[0m[[0mdebug[0m] [0m    ocsp: Boolean = ocsp,[0m
[0m[[0mdebug[0m] [0m    pluggability: Boolean = pluggability,[0m
[0m[[0mdebug[0m] [0m    record: Option[com.typesafe.sslconfig.ssl.SSLDebugRecordOptions] = record,[0m
[0m[[0mdebug[0m] [0m    session: Boolean = session,[0m
[0m[[0mdebug[0m] [0m    sessioncache: Boolean = sessioncache,[0m
[0m[[0mdebug[0m] [0m    ssl: Boolean = ssl,[0m
[0m[[0mdebug[0m] [0m    sslctx: Boolean = sslctx,[0m
[0m[[0mdebug[0m] [0m    trustmanager: Boolean = trustmanager): SSLDebugConfig = new SSLDebugConfig([0m
[0m[[0mdebug[0m] [0m      all = all,[0m
[0m[[0mdebug[0m] [0m      certpath = certpath,[0m
[0m[[0mdebug[0m] [0m      defaultctx = defaultctx,[0m
[0m[[0mdebug[0m] [0m      handshake = handshake,[0m
[0m[[0mdebug[0m] [0m      keygen = keygen,[0m
[0m[[0mdebug[0m] [0m      keymanager = keymanager,[0m
[0m[[0mdebug[0m] [0m      ocsp = ocsp,[0m
[0m[[0mdebug[0m] [0m      pluggability = pluggability,[0m
[0m[[0mdebug[0m] [0m      record = record,[0m
[0m[[0mdebug[0m] [0m      session = session,[0m
[0m[[0mdebug[0m] [0m      sessioncache = sessioncache,[0m
[0m[[0mdebug[0m] [0m      ssl = ssl,[0m
[0m[[0mdebug[0m] [0m      sslctx = sslctx,[0m
[0m[[0mdebug[0m] [0m      trustmanager = trustmanager)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  override def toString =[0m
[0m[[0mdebug[0m] [0m    s"""SSLDebugConfig(${all},${certpath},${defaultctx},${handshake},${keygen},${keymanager},${ocsp},${pluggability},${record},${session},${sessioncache},${ssl},${sslctx},${trustmanager})"""[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mobject SSLDebugConfig {[0m
[0m[[0mdebug[0m] [0m  def apply() = new SSLDebugConfig()[0m
[0m[[0mdebug[0m] [0m  /** Java API */[0m
[0m[[0mdebug[0m] [0m  def getInstance() = apply()[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * SSL handshake debugging options.[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0mfinal class SSLDebugHandshakeOptions private[sslconfig]([0m
[0m[[0mdebug[0m] [0m  val data: Boolean = false,[0m
[0m[[0mdebug[0m] [0m  val verbose: Boolean = false) {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def withData(value: Boolean): SSLDebugHandshakeOptions = copy(data = value)[0m
[0m[[0mdebug[0m] [0m  def withVerbose(value: Boolean): SSLDebugHandshakeOptions = copy(verbose = value)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  private def copy([0m
[0m[[0mdebug[0m] [0m    data: Boolean = data,[0m
[0m[[0mdebug[0m] [0m    verbose: Boolean = verbose): SSLDebugHandshakeOptions = new SSLDebugHandshakeOptions([0m
[0m[[0mdebug[0m] [0m      data = data,[0m
[0m[[0mdebug[0m] [0m      verbose = verbose)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  override def toString =[0m
[0m[[0mdebug[0m] [0m    s"""SSLDebugHandshakeOptions(${data},${verbose})"""[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mobject SSLDebugHandshakeOptions {[0m
[0m[[0mdebug[0m] [0m  def apply() = new SSLDebugHandshakeOptions()[0m
[0m[[0mdebug[0m] [0m  /** Java API */[0m
[0m[[0mdebug[0m] [0m  def getInstance() = apply()[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * SSL record debugging options.[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0mfinal class SSLDebugRecordOptions private[sslconfig]([0m
[0m[[0mdebug[0m] [0m  val packet: Boolean = false,[0m
[0m[[0mdebug[0m] [0m  val plaintext: Boolean = false) {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def withPacket(value: Boolean): SSLDebugRecordOptions = copy(packet = value)[0m
[0m[[0mdebug[0m] [0m  def withPlaintext(value: Boolean): SSLDebugRecordOptions = copy(plaintext = value)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  private def copy([0m
[0m[[0mdebug[0m] [0m    packet: Boolean = packet,[0m
[0m[[0mdebug[0m] [0m    plaintext: Boolean = plaintext): SSLDebugRecordOptions = new SSLDebugRecordOptions([0m
[0m[[0mdebug[0m] [0m      packet = packet,[0m
[0m[[0mdebug[0m] [0m      plaintext = plaintext)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  override def toString =[0m
[0m[[0mdebug[0m] [0m    s"""SSLDebugRecordOptions(${packet},${plaintext})"""[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mobject SSLDebugRecordOptions {[0m
[0m[[0mdebug[0m] [0m  def apply() = new SSLDebugRecordOptions()[0m
[0m[[0mdebug[0m] [0m  /** Java API */[0m
[0m[[0mdebug[0m] [0m  def getInstance() = apply()[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * Configuration for specifying loose (potentially dangerous) ssl config.[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * @param allowWeakCiphers Whether weak ciphers should be allowed or not.[0m
[0m[[0mdebug[0m] [0m * @param allowWeakProtocols Whether weak protocols should be allowed or not.[0m
[0m[[0mdebug[0m] [0m * @param allowLegacyHelloMessages Whether legacy hello messages should be allowed or not. If None, uses the platform[0m
[0m[[0mdebug[0m] [0m *                                 default.[0m
[0m[[0mdebug[0m] [0m * @param allowUnsafeRenegotiation Whether unsafe renegotiation should be allowed or not. If None, uses the platform[0m
[0m[[0mdebug[0m] [0m *                                 default.[0m
[0m[[0mdebug[0m] [0m * @param disableHostnameVerification Whether hostname verification should be disabled.[0m
[0m[[0mdebug[0m] [0m * @param disableSNI Whether SNI should be disabled (up to client library to respect this setting or not)[0m
[0m[[0mdebug[0m] [0m * @param acceptAnyCertificate Whether any X.509 certificate should be accepted or not.[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0mfinal class SSLLooseConfig private[sslconfig]([0m
[0m[[0mdebug[0m] [0m  val acceptAnyCertificate: Boolean = false,[0m
[0m[[0mdebug[0m] [0m  val allowLegacyHelloMessages: Option[Boolean] = None,[0m
[0m[[0mdebug[0m] [0m  val allowUnsafeRenegotiation: Option[Boolean]= None,[0m
[0m[[0mdebug[0m] [0m  val allowWeakCiphers: Boolean = false,[0m
[0m[[0mdebug[0m] [0m  val allowWeakProtocols: Boolean = false,[0m
[0m[[0mdebug[0m] [0m  val disableHostnameVerification: Boolean = false,[0m
[0m[[0mdebug[0m] [0m  val disableSNI: Boolean = false) {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def withAcceptAnyCertificate(value: Boolean): SSLLooseConfig = copy(acceptAnyCertificate = value)[0m
[0m[[0mdebug[0m] [0m  def withAllowLegacyHelloMessages(value: Option[Boolean]): SSLLooseConfig = copy(allowLegacyHelloMessages = value)[0m
[0m[[0mdebug[0m] [0m  def withAllowUnsafeRenegotiation(value: Option[Boolean]): SSLLooseConfig = copy(allowUnsafeRenegotiation = value)[0m
[0m[[0mdebug[0m] [0m  def withAllowWeakCiphers(value: Boolean): SSLLooseConfig = copy(allowWeakCiphers = value)[0m
[0m[[0mdebug[0m] [0m  def withAllowWeakProtocols(value: Boolean): SSLLooseConfig = copy(allowWeakProtocols = value)[0m
[0m[[0mdebug[0m] [0m  def withDisableHostnameVerification(value: Boolean): SSLLooseConfig = copy(disableHostnameVerification = value)[0m
[0m[[0mdebug[0m] [0m  def withDisableSNI(value: Boolean): SSLLooseConfig = copy(disableSNI = value)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  private def copy([0m
[0m[[0mdebug[0m] [0m    acceptAnyCertificate: Boolean = acceptAnyCertificate,[0m
[0m[[0mdebug[0m] [0m    allowLegacyHelloMessages: Option[Boolean] = allowLegacyHelloMessages,[0m
[0m[[0mdebug[0m] [0m    allowUnsafeRenegotiation: Option[Boolean] = allowUnsafeRenegotiation,[0m
[0m[[0mdebug[0m] [0m    allowWeakCiphers: Boolean = allowWeakCiphers,[0m
[0m[[0mdebug[0m] [0m    allowWeakProtocols: Boolean = allowWeakProtocols,[0m
[0m[[0mdebug[0m] [0m    disableHostnameVerification: Boolean = disableHostnameVerification,[0m
[0m[[0mdebug[0m] [0m    disableSNI: Boolean = disableSNI): SSLLooseConfig = new SSLLooseConfig([0m
[0m[[0mdebug[0m] [0m      acceptAnyCertificate = acceptAnyCertificate,[0m
[0m[[0mdebug[0m] [0m      allowLegacyHelloMessages = allowLegacyHelloMessages,[0m
[0m[[0mdebug[0m] [0m      allowUnsafeRenegotiation = allowUnsafeRenegotiation,[0m
[0m[[0mdebug[0m] [0m      allowWeakCiphers = allowWeakCiphers,[0m
[0m[[0mdebug[0m] [0m      allowWeakProtocols = allowWeakProtocols,[0m
[0m[[0mdebug[0m] [0m      disableHostnameVerification = disableHostnameVerification,[0m
[0m[[0mdebug[0m] [0m      disableSNI = disableSNI)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  override def toString =[0m
[0m[[0mdebug[0m] [0m    s"""SSLLooseConfig(${acceptAnyCertificate},${allowLegacyHelloMessages},${allowUnsafeRenegotiation},${allowWeakCiphers},${allowWeakProtocols},${disableHostnameVerification},${disableSNI})"""[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mobject SSLLooseConfig {[0m
[0m[[0mdebug[0m] [0m  def apply() = new SSLLooseConfig()[0m
[0m[[0mdebug[0m] [0m  /** Java API */[0m
[0m[[0mdebug[0m] [0m  def getInstance() = apply()[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * Carries values which will be later set on an [[SSLParameters]] object.[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * @param clientAuth see [[ClientAuth]] for detailed docs on ClientAuth modes[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0mfinal class SSLParametersConfig private[sslconfig]([0m
[0m[[0mdebug[0m] [0m  val clientAuth: ClientAuth = ClientAuth.Default,[0m
[0m[[0mdebug[0m] [0m  val protocols: scala.collection.immutable.Seq[String] = Nil) {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def withClientAuth(value: com.typesafe.sslconfig.ssl.ClientAuth): SSLParametersConfig = copy(clientAuth = value)[0m
[0m[[0mdebug[0m] [0m  def withProtocols(value: scala.collection.immutable.Seq[String]): SSLParametersConfig = copy(protocols = value)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  private def copy([0m
[0m[[0mdebug[0m] [0m    clientAuth: com.typesafe.sslconfig.ssl.ClientAuth = clientAuth,[0m
[0m[[0mdebug[0m] [0m    protocols: scala.collection.immutable.Seq[String] = protocols): SSLParametersConfig = new SSLParametersConfig([0m
[0m[[0mdebug[0m] [0m      clientAuth = clientAuth,[0m
[0m[[0mdebug[0m] [0m      protocols = protocols)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  override def toString =[0m
[0m[[0mdebug[0m] [0m    s"""SSLParametersConfig(${clientAuth},${protocols})"""[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mobject SSLParametersConfig {[0m
[0m[[0mdebug[0m] [0m  def apply() = new SSLParametersConfig()[0m
[0m[[0mdebug[0m] [0m  /** Java API */[0m
[0m[[0mdebug[0m] [0m  def getInstance() = apply()[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * The SSL configuration.[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * @param default Whether we should use the default JVM SSL configuration or not.[0m
[0m[[0mdebug[0m] [0m * @param protocol The SSL protocol to use. Defaults to TLSv1.2.[0m
[0m[[0mdebug[0m] [0m * @param checkRevocation Whether revocation lists should be checked, if None, defaults to platform default setting.[0m
[0m[[0mdebug[0m] [0m * @param revocationLists The revocation lists to check.[0m
[0m[[0mdebug[0m] [0m * @param enabledCipherSuites If defined, override the platform default cipher suites.[0m
[0m[[0mdebug[0m] [0m * @param enabledProtocols If defined, override the platform default protocols.[0m
[0m[[0mdebug[0m] [0m * @param disabledSignatureAlgorithms The disabled signature algorithms.[0m
[0m[[0mdebug[0m] [0m * @param disabledKeyAlgorithms The disabled key algorithms.[0m
[0m[[0mdebug[0m] [0m * @param keyManagerConfig The key manager configuration.[0m
[0m[[0mdebug[0m] [0m * @param trustManagerConfig The trust manager configuration.[0m
[0m[[0mdebug[0m] [0m * @param hostnameVerifierClass The hostname verifier class.[0m
[0m[[0mdebug[0m] [0m * @param secureRandom The SecureRandom instance to use. Let the platform choose if None.[0m
[0m[[0mdebug[0m] [0m * @param debug The debug config.[0m
[0m[[0mdebug[0m] [0m * @param loose Loose configuratino parameters[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0mfinal class SSLConfigSettings private[sslconfig]([0m
[0m[[0mdebug[0m] [0m  val default: Boolean = false,[0m
[0m[[0mdebug[0m] [0m  val protocol: String = "TLSv1.2",[0m
[0m[[0mdebug[0m] [0m  val checkRevocation: Option[Boolean] = None,[0m
[0m[[0mdebug[0m] [0m  val revocationLists: Option[immutable.Seq[URL]] = None,[0m
[0m[[0mdebug[0m] [0m  val enabledCipherSuites: Option[immutable.Seq[String]] = None,[0m
[0m[[0mdebug[0m] [0m  val enabledProtocols: Option[immutable.Seq[String]] = Some(List("TLSv1.2", "TLSv1.1", "TLSv1")),[0m
[0m[[0mdebug[0m] [0m  val disabledSignatureAlgorithms: immutable.Seq[String] = List("MD2", "MD4", "MD5"),[0m
[0m[[0mdebug[0m] [0m  val disabledKeyAlgorithms: immutable.Seq[String] = List("RSA keySize < 2048", "DSA keySize < 2048", "EC keySize < 224"),[0m
[0m[[0mdebug[0m] [0m  val sslParametersConfig: SSLParametersConfig = SSLParametersConfig(),[0m
[0m[[0mdebug[0m] [0m  val keyManagerConfig: KeyManagerConfig = KeyManagerConfig(),[0m
[0m[[0mdebug[0m] [0m  val trustManagerConfig: TrustManagerConfig = TrustManagerConfig(),[0m
[0m[[0mdebug[0m] [0m  val hostnameVerifierClass: Class[_ <: HostnameVerifier] = classOf[DefaultHostnameVerifier],[0m
[0m[[0mdebug[0m] [0m  val secureRandom: Option[SecureRandom] = None,[0m
[0m[[0mdebug[0m] [0m  val debug: SSLDebugConfig = SSLDebugConfig(),[0m
[0m[[0mdebug[0m] [0m  val loose: SSLLooseConfig = SSLLooseConfig()) {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def withCheckRevocation(value: Option[Boolean]): SSLConfigSettings = copy(checkRevocation = value)[0m
[0m[[0mdebug[0m] [0m  def withDebug(value: com.typesafe.sslconfig.ssl.SSLDebugConfig): SSLConfigSettings = copy(debug = value)[0m
[0m[[0mdebug[0m] [0m  def withDefault(value: Boolean): SSLConfigSettings = copy(default = value)[0m
[0m[[0mdebug[0m] [0m  def withDisabledKeyAlgorithms(value: scala.collection.immutable.Seq[String]): SSLConfigSettings = copy(disabledKeyAlgorithms = value)[0m
[0m[[0mdebug[0m] [0m  def withDisabledSignatureAlgorithms(value: scala.collection.immutable.Seq[String]): SSLConfigSettings = copy(disabledSignatureAlgorithms = value)[0m
[0m[[0mdebug[0m] [0m  def withEnabledCipherSuites(value: Option[scala.collection.immutable.Seq[String]]): SSLConfigSettings = copy(enabledCipherSuites = value)[0m
[0m[[0mdebug[0m] [0m  def withEnabledProtocols(value: Option[scala.collection.immutable.Seq[String]]): SSLConfigSettings = copy(enabledProtocols = value)[0m
[0m[[0mdebug[0m] [0m  def withHostnameVerifierClass(value: Class[_ <: javax.net.ssl.HostnameVerifier]): SSLConfigSettings = copy(hostnameVerifierClass = value)[0m
[0m[[0mdebug[0m] [0m  def withKeyManagerConfig(value: com.typesafe.sslconfig.ssl.KeyManagerConfig): SSLConfigSettings = copy(keyManagerConfig = value)[0m
[0m[[0mdebug[0m] [0m  def withLoose(value: com.typesafe.sslconfig.ssl.SSLLooseConfig): SSLConfigSettings = copy(loose = value)[0m
[0m[[0mdebug[0m] [0m  def withProtocol(value: String): SSLConfigSettings = copy(protocol = value)[0m
[0m[[0mdebug[0m] [0m  def withRevocationLists(value: Option[scala.collection.immutable.Seq[java.net.URL]]): SSLConfigSettings = copy(revocationLists = value)[0m
[0m[[0mdebug[0m] [0m  def withSecureRandom(value: Option[java.security.SecureRandom]): SSLConfigSettings = copy(secureRandom = value)[0m
[0m[[0mdebug[0m] [0m  def withSslParametersConfig(value: com.typesafe.sslconfig.ssl.SSLParametersConfig): SSLConfigSettings = copy(sslParametersConfig = value)[0m
[0m[[0mdebug[0m] [0m  def withTrustManagerConfig(value: com.typesafe.sslconfig.ssl.TrustManagerConfig): SSLConfigSettings = copy(trustManagerConfig = value)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  private def copy([0m
[0m[[0mdebug[0m] [0m    checkRevocation: Option[Boolean] = checkRevocation,[0m
[0m[[0mdebug[0m] [0m    debug: com.typesafe.sslconfig.ssl.SSLDebugConfig = debug,[0m
[0m[[0mdebug[0m] [0m    default: Boolean = default,[0m
[0m[[0mdebug[0m] [0m    disabledKeyAlgorithms: scala.collection.immutable.Seq[String] = disabledKeyAlgorithms,[0m
[0m[[0mdebug[0m] [0m    disabledSignatureAlgorithms: scala.collection.immutable.Seq[String] = disabledSignatureAlgorithms,[0m
[0m[[0mdebug[0m] [0m    enabledCipherSuites: Option[scala.collection.immutable.Seq[String]] = enabledCipherSuites,[0m
[0m[[0mdebug[0m] [0m    enabledProtocols: Option[scala.collection.immutable.Seq[String]] = enabledProtocols,[0m
[0m[[0mdebug[0m] [0m    hostnameVerifierClass: Class[_ <: javax.net.ssl.HostnameVerifier] = hostnameVerifierClass,[0m
[0m[[0mdebug[0m] [0m    keyManagerConfig: com.typesafe.sslconfig.ssl.KeyManagerConfig = keyManagerConfig,[0m
[0m[[0mdebug[0m] [0m    loose: com.typesafe.sslconfig.ssl.SSLLooseConfig = loose,[0m
[0m[[0mdebug[0m] [0m    protocol: String = protocol,[0m
[0m[[0mdebug[0m] [0m    revocationLists: Option[scala.collection.immutable.Seq[java.net.URL]] = revocationLists,[0m
[0m[[0mdebug[0m] [0m    secureRandom: Option[java.security.SecureRandom] = secureRandom,[0m
[0m[[0mdebug[0m] [0m    sslParametersConfig: com.typesafe.sslconfig.ssl.SSLParametersConfig = sslParametersConfig,[0m
[0m[[0mdebug[0m] [0m    trustManagerConfig: com.typesafe.sslconfig.ssl.TrustManagerConfig = trustManagerConfig): SSLConfigSettings = new SSLConfigSettings([0m
[0m[[0mdebug[0m] [0m      checkRevocation = checkRevocation,[0m
[0m[[0mdebug[0m] [0m      debug = debug,[0m
[0m[[0mdebug[0m] [0m      default = default,[0m
[0m[[0mdebug[0m] [0m      disabledKeyAlgorithms = disabledKeyAlgorithms,[0m
[0m[[0mdebug[0m] [0m      disabledSignatureAlgorithms = disabledSignatureAlgorithms,[0m
[0m[[0mdebug[0m] [0m      enabledCipherSuites = enabledCipherSuites,[0m
[0m[[0mdebug[0m] [0m      enabledProtocols = enabledProtocols,[0m
[0m[[0mdebug[0m] [0m      hostnameVerifierClass = hostnameVerifierClass,[0m
[0m[[0mdebug[0m] [0m      keyManagerConfig = keyManagerConfig,[0m
[0m[[0mdebug[0m] [0m      loose = loose,[0m
[0m[[0mdebug[0m] [0m      protocol = protocol,[0m
[0m[[0mdebug[0m] [0m      revocationLists = revocationLists,[0m
[0m[[0mdebug[0m] [0m      secureRandom = secureRandom,[0m
[0m[[0mdebug[0m] [0m      sslParametersConfig = sslParametersConfig,[0m
[0m[[0mdebug[0m] [0m      trustManagerConfig = trustManagerConfig)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  override def toString =[0m
[0m[[0mdebug[0m] [0m    s"""SSLConfig(${checkRevocation},${debug},${default},${disabledKeyAlgorithms},${disabledSignatureAlgorithms},${enabledCipherSuites},${enabledProtocols},${hostnameVerifierClass},${keyManagerConfig},${loose},${protocol},${revocationLists},${secureRandom},${sslParametersConfig},${trustManagerConfig})"""[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mobject SSLConfigSettings {[0m
[0m[[0mdebug[0m] [0m  def apply() = new SSLConfigSettings()[0m
[0m[[0mdebug[0m] [0m  /** Java API */[0m
[0m[[0mdebug[0m] [0m  def getInstance() = apply()[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * Factory for creating SSL config (for use from Java).[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0mobject SSLConfigFactory {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /** Parses the given config into an SSLConfig object, as given (does not select sub-config sections). */[0m
[0m[[0mdebug[0m] [0m  def parse(config: Config): SSLConfigSettings =[0m
[0m[[0mdebug[0m] [0m    new SSLConfigParser(com.typesafe.sslconfig.util.EnrichedConfig(config), getClass.getClassLoader).parse()[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Create an instance of the default config[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def defaultConfig = SSLConfigSettings()[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mclass SSLConfigParser(c: EnrichedConfig, classLoader: ClassLoader) {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def parse(): SSLConfigSettings = {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val default = c.get[Boolean]("default")[0m
[0m[[0mdebug[0m] [0m    val protocol = c.get[String]("protocol")[0m
[0m[[0mdebug[0m] [0m    val checkRevocation = c.getOptional[Boolean]("checkRevocation")[0m
[0m[[0mdebug[0m] [0m    val revocationLists: Option[immutable.Seq[URL]] = Some([0m
[0m[[0mdebug[0m] [0m      c.getSeq[String]("revocationLists").map(new URL(_))[0m
[0m[[0mdebug[0m] [0m    ).filter(_.nonEmpty)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val debug = parseDebug(c.get[EnrichedConfig]("debug"))[0m
[0m[[0mdebug[0m] [0m    val looseOptions = parseLooseOptions(c.get[EnrichedConfig]("loose"))[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val ciphers = Some(c.getSeq[String]("enabledCipherSuites")).filter(_.nonEmpty)[0m
[0m[[0mdebug[0m] [0m    val protocols = Some(c.getSeq[String]("enabledProtocols")).filter(_.nonEmpty)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val hostnameVerifierClass = c.getOptional[String]("hostnameVerifierClass") match {[0m
[0m[[0mdebug[0m] [0m      case None       => classOf[DefaultHostnameVerifier][0m
[0m[[0mdebug[0m] [0m      case Some(fqcn) => classLoader.loadClass(fqcn).asSubclass(classOf[HostnameVerifier])[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val disabledSignatureAlgorithms = c.getSeq[String]("disabledSignatureAlgorithms")[0m
[0m[[0mdebug[0m] [0m    val disabledKeyAlgorithms = c.getSeq[String]("disabledKeyAlgorithms")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val keyManagers = parseKeyManager(c.get[EnrichedConfig]("keyManager"))[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val trustManagers = parseTrustManager(c.get[EnrichedConfig]("trustManager"))[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val sslParametersConfig = parseSSLParameters(c.get[EnrichedConfig]("sslParameters"))[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    new SSLConfigSettings([0m
[0m[[0mdebug[0m] [0m      default = default,[0m
[0m[[0mdebug[0m] [0m      protocol = protocol,[0m
[0m[[0mdebug[0m] [0m      checkRevocation = checkRevocation,[0m
[0m[[0mdebug[0m] [0m      revocationLists = revocationLists,[0m
[0m[[0mdebug[0m] [0m      enabledCipherSuites = ciphers,[0m
[0m[[0mdebug[0m] [0m      enabledProtocols = protocols,[0m
[0m[[0mdebug[0m] [0m      keyManagerConfig = keyManagers,[0m
[0m[[0mdebug[0m] [0m      hostnameVerifierClass = hostnameVerifierClass,[0m
[0m[[0mdebug[0m] [0m      disabledSignatureAlgorithms = disabledSignatureAlgorithms,[0m
[0m[[0mdebug[0m] [0m      disabledKeyAlgorithms = disabledKeyAlgorithms,[0m
[0m[[0mdebug[0m] [0m      sslParametersConfig = sslParametersConfig,[0m
[0m[[0mdebug[0m] [0m      trustManagerConfig = trustManagers,[0m
[0m[[0mdebug[0m] [0m      secureRandom = None,[0m
[0m[[0mdebug[0m] [0m      debug = debug,[0m
[0m[[0mdebug[0m] [0m      loose = looseOptions)[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Parses "ssl-config.loose" section.[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def parseLooseOptions(config: EnrichedConfig): SSLLooseConfig = {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val allowWeakProtocols = config.get[Boolean]("allowWeakProtocols")[0m
[0m[[0mdebug[0m] [0m    val allowWeakCiphers = config.get[Boolean]("allowWeakCiphers")[0m
[0m[[0mdebug[0m] [0m    val allowMessages = config.getOptional[Boolean]("allowLegacyHelloMessages")[0m
[0m[[0mdebug[0m] [0m    val allowUnsafeRenegotiation = config.getOptional[Boolean]("allowUnsafeRenegotiation")[0m
[0m[[0mdebug[0m] [0m    val disableHostnameVerification = config.get[Boolean]("disableHostnameVerification")[0m
[0m[[0mdebug[0m] [0m    val disableSNI = config.get[Boolean]("disableSNI")[0m
[0m[[0mdebug[0m] [0m    val acceptAnyCertificate = config.get[Boolean]("acceptAnyCertificate")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    new SSLLooseConfig([0m
[0m[[0mdebug[0m] [0m      allowWeakCiphers = allowWeakCiphers,[0m
[0m[[0mdebug[0m] [0m      allowWeakProtocols = allowWeakProtocols,[0m
[0m[[0mdebug[0m] [0m      allowLegacyHelloMessages = allowMessages,[0m
[0m[[0mdebug[0m] [0m      allowUnsafeRenegotiation = allowUnsafeRenegotiation,[0m
[0m[[0mdebug[0m] [0m      disableHostnameVerification = disableHostnameVerification,[0m
[0m[[0mdebug[0m] [0m      disableSNI = disableSNI,[0m
[0m[[0mdebug[0m] [0m      acceptAnyCertificate = acceptAnyCertificate[0m
[0m[[0mdebug[0m] [0m    )[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Parses the "ssl-config.debug" section.[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def parseDebug(config: EnrichedConfig): SSLDebugConfig = {[0m
[0m[[0mdebug[0m] [0m    val certpath = config.get[Boolean]("certpath")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    if (config.get[Boolean]("all")) {[0m
[0m[[0mdebug[0m] [0m      new SSLDebugConfig(all = true, certpath = certpath)[0m
[0m[[0mdebug[0m] [0m    } else {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m      val record: Option[SSLDebugRecordOptions] = if (config.get[Boolean]("record")) {[0m
[0m[[0mdebug[0m] [0m        val plaintext = config.get[Boolean]("plaintext")[0m
[0m[[0mdebug[0m] [0m        val packet = config.get[Boolean]("packet")[0m
[0m[[0mdebug[0m] [0m        Some(new SSLDebugRecordOptions(plaintext = plaintext, packet = packet))[0m
[0m[[0mdebug[0m] [0m      } else None[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m      val handshake = if (config.get[Boolean]("handshake")) {[0m
[0m[[0mdebug[0m] [0m        val data = config.get[Boolean]("data")[0m
[0m[[0mdebug[0m] [0m        val verbose = config.get[Boolean]("verbose")[0m
[0m[[0mdebug[0m] [0m        Some(new SSLDebugHandshakeOptions(data = data, verbose = verbose))[0m
[0m[[0mdebug[0m] [0m      } else {[0m
[0m[[0mdebug[0m] [0m        None[0m
[0m[[0mdebug[0m] [0m      }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m      val keygen = config.get[Boolean]("keygen")[0m
[0m[[0mdebug[0m] [0m      val session = config.get[Boolean]("session")[0m
[0m[[0mdebug[0m] [0m      val defaultctx = config.get[Boolean]("defaultctx")[0m
[0m[[0mdebug[0m] [0m      val sslctx = config.get[Boolean]("sslctx")[0m
[0m[[0mdebug[0m] [0m      val sessioncache = config.get[Boolean]("sessioncache")[0m
[0m[[0mdebug[0m] [0m      val keymanager = config.get[Boolean]("keymanager")[0m
[0m[[0mdebug[0m] [0m      val trustmanager = config.get[Boolean]("trustmanager")[0m
[0m[[0mdebug[0m] [0m      val pluggability = config.get[Boolean]("pluggability")[0m
[0m[[0mdebug[0m] [0m      val ssl = config.get[Boolean]("ssl")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m      new SSLDebugConfig([0m
[0m[[0mdebug[0m] [0m        ssl = ssl,[0m
[0m[[0mdebug[0m] [0m        record = record,[0m
[0m[[0mdebug[0m] [0m        handshake = handshake,[0m
[0m[[0mdebug[0m] [0m        keygen = keygen,[0m
[0m[[0mdebug[0m] [0m        session = session,[0m
[0m[[0mdebug[0m] [0m        defaultctx = defaultctx,[0m
[0m[[0mdebug[0m] [0m        sslctx = sslctx,[0m
[0m[[0mdebug[0m] [0m        sessioncache = sessioncache,[0m
[0m[[0mdebug[0m] [0m        keymanager = keymanager,[0m
[0m[[0mdebug[0m] [0m        trustmanager = trustmanager,[0m
[0m[[0mdebug[0m] [0m        pluggability = pluggability,[0m
[0m[[0mdebug[0m] [0m        certpath = certpath)[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Parses the "ssl-config.keyManager { stores = [ ... ]" section of configuration.[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def parseKeyStoreInfo(config: EnrichedConfig): KeyStoreConfig = {[0m
[0m[[0mdebug[0m] [0m    val storeType = config.getOptional[String]("type").getOrElse(KeyStore.getDefaultType)[0m
[0m[[0mdebug[0m] [0m    val path = config.getOptional[String]("path")[0m
[0m[[0mdebug[0m] [0m    val classPath = config.getOptional[Boolean]("classpath").getOrElse(false)[0m
[0m[[0mdebug[0m] [0m    val data = config.getOptional[String]("data")[0m
[0m[[0mdebug[0m] [0m    val password = config.getOptional[String]("password")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    new KeyStoreConfig(filePath = path, storeType = storeType, isFileOnClasspath = classPath, data = data, password = password)[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Parses the "ssl-config.trustManager { stores = [ ... ]" section of configuration.[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def parseTrustStoreInfo(config: EnrichedConfig): TrustStoreConfig = {[0m
[0m[[0mdebug[0m] [0m    val storeType = config.getOptional[String]("type").getOrElse(KeyStore.getDefaultType)[0m
[0m[[0mdebug[0m] [0m    val path = config.getOptional[String]("path")[0m
[0m[[0mdebug[0m] [0m    val classPath = config.getOptional[Boolean]("classpath").getOrElse(false)[0m
[0m[[0mdebug[0m] [0m    val data = config.getOptional[String]("data")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    new TrustStoreConfig(filePath = path, isFileOnClasspath = classPath, storeType = storeType, data = data)[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Parses the "ssl-config.keyManager" section of the configuration.[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def parseKeyManager(config: EnrichedConfig): KeyManagerConfig = {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val algorithm = config.getOptional[String]("algorithm") match {[0m
[0m[[0mdebug[0m] [0m      case None        => KeyManagerFactory.getDefaultAlgorithm[0m
[0m[[0mdebug[0m] [0m      case Some(other) => other[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val keyStoreInfos = config.getPrototypedSeq("stores").map { store =>[0m
[0m[[0mdebug[0m] [0m      parseKeyStoreInfo(store)[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    new KeyManagerConfig(algorithm, keyStoreInfos)[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Parses the "ssl-config.trustManager" section of configuration.[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def parseTrustManager(config: EnrichedConfig): TrustManagerConfig = {[0m
[0m[[0mdebug[0m] [0m    val algorithm = config.getOptional[String]("algorithm") match {[0m
[0m[[0mdebug[0m] [0m      case None        => TrustManagerFactory.getDefaultAlgorithm[0m
[0m[[0mdebug[0m] [0m      case Some(other) => other[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val trustStoreInfos = config.getPrototypedSeq("stores").map { store =>[0m
[0m[[0mdebug[0m] [0m      parseTrustStoreInfo(store)[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    new TrustManagerConfig(algorithm, trustStoreInfos)[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def parseSSLParameters(config: EnrichedConfig): SSLParametersConfig = {[0m
[0m[[0mdebug[0m] [0m    // could instantiate SSLParameters directly, but seems less clean, here we only parse config[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val clientAuth = config.getOptional[String]("clientAuth") match {[0m
[0m[[0mdebug[0m] [0m      case Some("none")           => ClientAuth.None[0m
[0m[[0mdebug[0m] [0m      case Some("want")           => ClientAuth.Want[0m
[0m[[0mdebug[0m] [0m      case Some("need")           => ClientAuth.Need[0m
[0m[[0mdebug[0m] [0m      case None | Some(_) => ClientAuth.Default[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val protocols = config.getSeq[String]("protocols")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    new SSLParametersConfig(clientAuth, protocols)[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * An SSLEngine can either demand, allow or ignore its peerâ€™s authentication[0m
[0m[[0mdebug[0m] [0m * (via certificates), where `Need` will fail the handshake if the peer does[0m
[0m[[0mdebug[0m] [0m * not provide valid credentials, `Want` allows the peer to send credentials[0m
[0m[[0mdebug[0m] [0m * and verifies them if provided, and `None` disables peer certificate[0m
[0m[[0mdebug[0m] [0m * verification.[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * See the documentation for `SSLEngine::setWantClientAuth` for more information.[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0msealed abstract class ClientAuth[0m
[0m[[0mdebug[0m] [0mobject ClientAuth {[0m
[0m[[0mdebug[0m] [0m  case object Default extends ClientAuth[0m
[0m[[0mdebug[0m] [0m  case object None extends ClientAuth[0m
[0m[[0mdebug[0m] [0m  case object Want extends ClientAuth[0m
[0m[[0mdebug[0m] [0m  case object Need extends ClientAuth[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def none: ClientAuth = None[0m
[0m[[0mdebug[0m] [0m  def want: ClientAuth = Want[0m
[0m[[0mdebug[0m] [0m  def need: ClientAuth = Need[0m
[0m[[0mdebug[0m] [0m  def defaultAuth: ClientAuth = Default // since `default` is a Java keyword[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mModified text of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/Config.scala is:[0m
[0m[[0mdebug[0m] [0mNone[0m
[0m[[0mdebug[0m] [0mAbout to create/update header for /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/FakeKeyStore.scala[0m
[0m[[0mdebug[0m] [0mFirst line of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/FakeKeyStore.scala is:[0m
[0m[[0mdebug[0m] [0mText of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/FakeKeyStore.scala is:[0m
[0m[[0mdebug[0m] [0m/*[0m
[0m[[0mdebug[0m] [0m * Copyright (C) 2015 Typesafe Inc. <http://www.typesafe.com>[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mpackage com.typesafe.sslconfig.ssl[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport java.security.{ KeyStore, SecureRandom, KeyPairGenerator, KeyPair }[0m
[0m[[0mdebug[0m] [0mimport com.typesafe.sslconfig.util.{ LoggerFactory, NoDepsLogger }[0m
[0m[[0mdebug[0m] [0mimport sun.security.x509._[0m
[0m[[0mdebug[0m] [0mimport java.util.Date[0m
[0m[[0mdebug[0m] [0mimport java.math.BigInteger[0m
[0m[[0mdebug[0m] [0mimport java.security.cert.X509Certificate[0m
[0m[[0mdebug[0m] [0mimport java.io._[0m
[0m[[0mdebug[0m] [0mimport javax.net.ssl.KeyManagerFactory[0m
[0m[[0mdebug[0m] [0mimport scala.util.Properties.isJavaAtLeast[0m
[0m[[0mdebug[0m] [0mimport java.security.interfaces.RSAPublicKey[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * A fake key store[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * Was: play.core.server.ssl.FakeKeyStore[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0mclass FakeKeyStore(mkLogger: LoggerFactory) {[0m
[0m[[0mdebug[0m] [0m  private val logger = mkLogger(getClass)[0m
[0m[[0mdebug[0m] [0m  val GeneratedKeyStore = "conf/generated.keystore"[0m
[0m[[0mdebug[0m] [0m  val DnName = "CN=localhost, OU=Unit Testing, O=Mavericks, L=Moon Base 1, ST=Cyberspace, C=CY"[0m
[0m[[0mdebug[0m] [0m  val SignatureAlgorithmOID = AlgorithmId.sha256WithRSAEncryption_oid[0m
[0m[[0mdebug[0m] [0m  val SignatureAlgorithmName = "SHA256withRSA"[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def shouldGenerate(keyStoreFile: File): Boolean = {[0m
[0m[[0mdebug[0m] [0m    import scala.collection.JavaConverters._[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    if (!keyStoreFile.exists()) {[0m
[0m[[0mdebug[0m] [0m      return true[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    // Should regenerate if we find an unacceptably weak key in there.[0m
[0m[[0mdebug[0m] [0m    val store = KeyStore.getInstance("JKS")[0m
[0m[[0mdebug[0m] [0m    val in = new FileInputStream(keyStoreFile)[0m
[0m[[0mdebug[0m] [0m    try {[0m
[0m[[0mdebug[0m] [0m      store.load(in, "".toCharArray)[0m
[0m[[0mdebug[0m] [0m    } finally {[0m
[0m[[0mdebug[0m] [0m      closeQuietly(in)[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m    store.aliases().asScala.foreach {[0m
[0m[[0mdebug[0m] [0m      alias =>[0m
[0m[[0mdebug[0m] [0m        Option(store.getCertificate(alias)).map {[0m
[0m[[0mdebug[0m] [0m          c =>[0m
[0m[[0mdebug[0m] [0m            val key: RSAPublicKey = c.getPublicKey.asInstanceOf[RSAPublicKey][0m
[0m[[0mdebug[0m] [0m            if (key.getModulus.bitLength < 2048 || key.getAlgorithm != SignatureAlgorithmName) {[0m
[0m[[0mdebug[0m] [0m              return true[0m
[0m[[0mdebug[0m] [0m            }[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    false[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def keyManagerFactory(appPath: File): KeyManagerFactory = {[0m
[0m[[0mdebug[0m] [0m    val keyStore = KeyStore.getInstance("JKS")[0m
[0m[[0mdebug[0m] [0m    val keyStoreFile = new File(appPath, GeneratedKeyStore)[0m
[0m[[0mdebug[0m] [0m    if (shouldGenerate(keyStoreFile)) {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m      logger.info("Generating HTTPS key pair in " + keyStoreFile.getAbsolutePath + " - this may take some time. If nothing happens, try moving the mouse/typing on the keyboard to generate some entropy.")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m      // Generate the key pair[0m
[0m[[0mdebug[0m] [0m      val keyPairGenerator = KeyPairGenerator.getInstance("RSA")[0m
[0m[[0mdebug[0m] [0m      keyPairGenerator.initialize(2048) // 2048 is the NIST acceptable key length until 2030[0m
[0m[[0mdebug[0m] [0m      val keyPair = keyPairGenerator.generateKeyPair()[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m      // Generate a self signed certificate[0m
[0m[[0mdebug[0m] [0m      val cert = createSelfSignedCertificate(keyPair)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m      // Create the key store, first set the store pass[0m
[0m[[0mdebug[0m] [0m      keyStore.load(null, "".toCharArray)[0m
[0m[[0mdebug[0m] [0m      keyStore.setKeyEntry("playgenerated", keyPair.getPrivate, "".toCharArray, Array(cert))[0m
[0m[[0mdebug[0m] [0m      keyStore.setCertificateEntry("playgeneratedtrusted", cert)[0m
[0m[[0mdebug[0m] [0m      val out = new FileOutputStream(keyStoreFile)[0m
[0m[[0mdebug[0m] [0m      try {[0m
[0m[[0mdebug[0m] [0m        keyStore.store(out, "".toCharArray)[0m
[0m[[0mdebug[0m] [0m      } finally {[0m
[0m[[0mdebug[0m] [0m        closeQuietly(out)[0m
[0m[[0mdebug[0m] [0m      }[0m
[0m[[0mdebug[0m] [0m    } else {[0m
[0m[[0mdebug[0m] [0m      val in = new FileInputStream(keyStoreFile)[0m
[0m[[0mdebug[0m] [0m      try {[0m
[0m[[0mdebug[0m] [0m        keyStore.load(in, "".toCharArray)[0m
[0m[[0mdebug[0m] [0m      } finally {[0m
[0m[[0mdebug[0m] [0m        closeQuietly(in)[0m
[0m[[0mdebug[0m] [0m      }[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    // Load the key and certificate into a key manager factory[0m
[0m[[0mdebug[0m] [0m    val kmf = KeyManagerFactory.getInstance("SunX509")[0m
[0m[[0mdebug[0m] [0m    kmf.init(keyStore, "".toCharArray)[0m
[0m[[0mdebug[0m] [0m    kmf[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def createSelfSignedCertificate(keyPair: KeyPair): X509Certificate = {[0m
[0m[[0mdebug[0m] [0m    val certInfo = new X509CertInfo()[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    // Serial number and version[0m
[0m[[0mdebug[0m] [0m    certInfo.set(X509CertInfo.SERIAL_NUMBER, new CertificateSerialNumber(new BigInteger(64, new SecureRandom())))[0m
[0m[[0mdebug[0m] [0m    certInfo.set(X509CertInfo.VERSION, new CertificateVersion(CertificateVersion.V3))[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    // Validity[0m
[0m[[0mdebug[0m] [0m    val validFrom = new Date()[0m
[0m[[0mdebug[0m] [0m    val validTo = new Date(validFrom.getTime + 50l * 365l * 24l * 60l * 60l * 1000l)[0m
[0m[[0mdebug[0m] [0m    val validity = new CertificateValidity(validFrom, validTo)[0m
[0m[[0mdebug[0m] [0m    certInfo.set(X509CertInfo.VALIDITY, validity)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    // Subject and issuer[0m
[0m[[0mdebug[0m] [0m    // Note: CertificateSubjectName and CertificateIssuerName are removed in Java 8[0m
[0m[[0mdebug[0m] [0m    // and when setting the subject or issuer just the X500Name should be used.[0m
[0m[[0mdebug[0m] [0m    val owner = new X500Name(DnName)[0m
[0m[[0mdebug[0m] [0m    val justName = isJavaAtLeast("1.8")[0m
[0m[[0mdebug[0m] [0m    certInfo.set(X509CertInfo.SUBJECT, if (justName) owner else new CertificateSubjectName(owner))[0m
[0m[[0mdebug[0m] [0m    certInfo.set(X509CertInfo.ISSUER, if (justName) owner else new CertificateIssuerName(owner))[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    // Key and algorithm[0m
[0m[[0mdebug[0m] [0m    certInfo.set(X509CertInfo.KEY, new CertificateX509Key(keyPair.getPublic))[0m
[0m[[0mdebug[0m] [0m    val algorithm = new AlgorithmId(SignatureAlgorithmOID)[0m
[0m[[0mdebug[0m] [0m    certInfo.set(X509CertInfo.ALGORITHM_ID, new CertificateAlgorithmId(algorithm))[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    // Create a new certificate and sign it[0m
[0m[[0mdebug[0m] [0m    val cert = new X509CertImpl(certInfo)[0m
[0m[[0mdebug[0m] [0m    cert.sign(keyPair.getPrivate, SignatureAlgorithmName)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    // Since the signature provider may have a different algorithm ID to what we think it should be,[0m
[0m[[0mdebug[0m] [0m    // we need to reset the algorithm ID, and resign the certificate[0m
[0m[[0mdebug[0m] [0m    val actualAlgorithm = cert.get(X509CertImpl.SIG_ALG).asInstanceOf[AlgorithmId][0m
[0m[[0mdebug[0m] [0m    certInfo.set(CertificateAlgorithmId.NAME + "." + CertificateAlgorithmId.ALGORITHM, actualAlgorithm)[0m
[0m[[0mdebug[0m] [0m    val newCert = new X509CertImpl(certInfo)[0m
[0m[[0mdebug[0m] [0m    newCert.sign(keyPair.getPrivate, SignatureAlgorithmName)[0m
[0m[[0mdebug[0m] [0m    newCert[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Close the given closeable quietly.[0m
[0m[[0mdebug[0m] [0m   *[0m
[0m[[0mdebug[0m] [0m   * Logs any IOExceptions encountered.[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def closeQuietly(closeable: Closeable) = {[0m
[0m[[0mdebug[0m] [0m    try {[0m
[0m[[0mdebug[0m] [0m      if (closeable != null) {[0m
[0m[[0mdebug[0m] [0m        closeable.close()[0m
[0m[[0mdebug[0m] [0m      }[0m
[0m[[0mdebug[0m] [0m    } catch {[0m
[0m[[0mdebug[0m] [0m      case e: IOException => logger.warn(s"Error closing stream. Cause: $e")[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mModified text of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/FakeKeyStore.scala is:[0m
[0m[[0mdebug[0m] [0mNone[0m
[0m[[0mdebug[0m] [0mAbout to create/update header for /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/SSLContextBuilder.scala[0m
[0m[[0mdebug[0m] [0mFirst line of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/SSLContextBuilder.scala is:[0m
[0m[[0mdebug[0m] [0mText of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/SSLContextBuilder.scala is:[0m
[0m[[0mdebug[0m] [0m/*[0m
[0m[[0mdebug[0m] [0m * Copyright (C) 2015 Typesafe Inc. <http://www.typesafe.com>[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mpackage com.typesafe.sslconfig.ssl[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport javax.net.ssl._[0m
[0m[[0mdebug[0m] [0mimport java.security._[0m
[0m[[0mdebug[0m] [0mimport java.security.cert._[0m
[0m[[0mdebug[0m] [0mimport java.io._[0m
[0m[[0mdebug[0m] [0mimport java.net.URL[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport com.typesafe.sslconfig.util.{ LoggerFactory, NoDepsLogger }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mtrait SSLContextBuilder {[0m
[0m[[0mdebug[0m] [0m  def build(): SSLContext[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * A simple SSL context builder.  If the keyManagers or trustManagers are empty, then null is used in the init method.[0m
[0m[[0mdebug[0m] [0m * Likewise, if secureRandom is None then null is used.[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0mclass SimpleSSLContextBuilder(protocol: String,[0m
[0m[[0mdebug[0m] [0m                              keyManagers: Seq[KeyManager],[0m
[0m[[0mdebug[0m] [0m                              trustManagers: Seq[TrustManager],[0m
[0m[[0mdebug[0m] [0m                              secureRandom: Option[SecureRandom]) extends SSLContextBuilder {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def nullIfEmpty[T](array: Array[T]) = {[0m
[0m[[0mdebug[0m] [0m    if (array.isEmpty) null else array[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Builds the appropriate SSL context manager.[0m
[0m[[0mdebug[0m] [0m   *[0m
[0m[[0mdebug[0m] [0m   * @return a configured SSL context.[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def build(): SSLContext = {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    // We deliberately do not pass in a provider, on the recommendation of[0m
[0m[[0mdebug[0m] [0m    // http://docs.oracle.com/javase/7/docs/technotes/guides/security/SunProviders.html#SunJSSEProvider[0m
[0m[[0mdebug[0m] [0m    //[0m
[0m[[0mdebug[0m] [0m    // "REMINDER: Cryptographic implementations in the JDK are distributed through several different providers[0m
[0m[[0mdebug[0m] [0m    // ("Sun", "SunJSSE", "SunJCE", "SunRsaSign") for both historical reasons and by the types of services provided.[0m
[0m[[0mdebug[0m] [0m    // General purpose applications SHOULD NOT request cryptographic services from specific providers."[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val sslContext = SSLContext.getInstance(protocol)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    sslContext.init(nullIfEmpty(keyManagers.toArray), nullIfEmpty(trustManagers.toArray), secureRandom.orNull)[0m
[0m[[0mdebug[0m] [0m    sslContext[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m// the KeyManagerFactory and TrustManagerFactory use final methods and protected abstract constructors that make[0m
[0m[[0mdebug[0m] [0m// mocking tough.  Either we provide a wrapper, or we set up our own "mock" provider, or we use Powermock.[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mtrait KeyManagerFactoryWrapper {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  @throws[KeyStoreException][0m
[0m[[0mdebug[0m] [0m  @throws[NoSuchAlgorithmException][0m
[0m[[0mdebug[0m] [0m  @throws[UnrecoverableKeyException][0m
[0m[[0mdebug[0m] [0m  def init(keystore: KeyStore, password: Array[Char]): Unit[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def getKeyManagers: Array[KeyManager][0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mtrait TrustManagerFactoryWrapper {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  @throws[InvalidAlgorithmParameterException][0m
[0m[[0mdebug[0m] [0m  def init(spec: ManagerFactoryParameters): Unit[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def getTrustManagers: Array[TrustManager][0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mclass DefaultKeyManagerFactoryWrapper(keyManagerAlgorithm: String) extends KeyManagerFactoryWrapper {[0m
[0m[[0mdebug[0m] [0m  private val instance = KeyManagerFactory.getInstance(keyManagerAlgorithm)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def init(keystore: KeyStore, password: Array[Char]) {[0m
[0m[[0mdebug[0m] [0m    instance.init(keystore, password)[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def getKeyManagers: Array[KeyManager] = instance.getKeyManagers[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mclass DefaultTrustManagerFactoryWrapper(trustManagerAlgorithm: String) extends TrustManagerFactoryWrapper {[0m
[0m[[0mdebug[0m] [0m  private val instance = TrustManagerFactory.getInstance(trustManagerAlgorithm)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def init(spec: ManagerFactoryParameters) {[0m
[0m[[0mdebug[0m] [0m    instance.init(spec)[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def getTrustManagers: Array[TrustManager] = instance.getTrustManagers[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * Creates an SSL context builder from info objects.[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0mclass ConfigSSLContextBuilder(mkLogger: LoggerFactory,[0m
[0m[[0mdebug[0m] [0m                              info: SSLConfigSettings,[0m
[0m[[0mdebug[0m] [0m                              keyManagerFactory: KeyManagerFactoryWrapper,[0m
[0m[[0mdebug[0m] [0m                              trustManagerFactory: TrustManagerFactoryWrapper) extends SSLContextBuilder {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  protected val logger = mkLogger(getClass)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def build(): SSLContext = {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val revocationLists = certificateRevocationList(info)[0m
[0m[[0mdebug[0m] [0m    val signatureConstraints = info.disabledSignatureAlgorithms.map(AlgorithmConstraintsParser.apply).toSet[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val keySizeConstraints = info.disabledKeyAlgorithms.map(AlgorithmConstraintsParser.apply).toSet[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val algorithmChecker = new AlgorithmChecker(mkLogger, signatureConstraints, keySizeConstraints)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val keyManagers: Seq[KeyManager] = if (info.keyManagerConfig.keyStoreConfigs.nonEmpty) {[0m
[0m[[0mdebug[0m] [0m      Seq(buildCompositeKeyManager(info.keyManagerConfig, algorithmChecker))[0m
[0m[[0mdebug[0m] [0m    } else Nil[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val trustManagers: Seq[TrustManager] = if (info.trustManagerConfig.trustStoreConfigs.nonEmpty) {[0m
[0m[[0mdebug[0m] [0m      Seq(buildCompositeTrustManager(info.trustManagerConfig, info.checkRevocation.getOrElse(false), revocationLists, algorithmChecker))[0m
[0m[[0mdebug[0m] [0m    } else Nil[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    buildSSLContext(info.protocol, keyManagers, trustManagers, info.secureRandom)[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def buildSSLContext(protocol: String,[0m
[0m[[0mdebug[0m] [0m                      keyManagers: Seq[KeyManager],[0m
[0m[[0mdebug[0m] [0m                      trustManagers: Seq[TrustManager],[0m
[0m[[0mdebug[0m] [0m                      secureRandom: Option[SecureRandom]) = {[0m
[0m[[0mdebug[0m] [0m    val builder = new SimpleSSLContextBuilder(protocol, keyManagers, trustManagers, secureRandom)[0m
[0m[[0mdebug[0m] [0m    builder.build()[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def buildCompositeKeyManager(keyManagerConfig: KeyManagerConfig, algorithmChecker: AlgorithmChecker) = {[0m
[0m[[0mdebug[0m] [0m    val keyManagers = keyManagerConfig.keyStoreConfigs.map {[0m
[0m[[0mdebug[0m] [0m      ksc =>[0m
[0m[[0mdebug[0m] [0m        buildKeyManager(ksc, algorithmChecker)[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m    new CompositeX509KeyManager(mkLogger, keyManagers)[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def buildCompositeTrustManager(trustManagerInfo: TrustManagerConfig,[0m
[0m[[0mdebug[0m] [0m                                 revocationEnabled: Boolean,[0m
[0m[[0mdebug[0m] [0m                                 revocationLists: Option[Seq[CRL]], algorithmChecker: AlgorithmChecker) = {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val trustManagers = trustManagerInfo.trustStoreConfigs.map {[0m
[0m[[0mdebug[0m] [0m      tsc =>[0m
[0m[[0mdebug[0m] [0m        buildTrustManager(tsc, revocationEnabled, revocationLists, algorithmChecker)[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m    new CompositeX509TrustManager(mkLogger, trustManagers, algorithmChecker)[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  // Get either a string or file based keystore builder from config.[0m
[0m[[0mdebug[0m] [0m  def keyStoreBuilder(ksc: KeyStoreConfig): KeyStoreBuilder = {[0m
[0m[[0mdebug[0m] [0m    val password = ksc.password.map(_.toCharArray)[0m
[0m[[0mdebug[0m] [0m    ksc.filePath.map { f =>[0m
[0m[[0mdebug[0m] [0m      if (ksc.isFileOnClasspath) {[0m
[0m[[0mdebug[0m] [0m        fileOnClasspathBuilder(ksc.storeType, f, password)[0m
[0m[[0mdebug[0m] [0m      } else {[0m
[0m[[0mdebug[0m] [0m        fileBuilder(ksc.storeType, f, password)[0m
[0m[[0mdebug[0m] [0m      }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    }.getOrElse {[0m
[0m[[0mdebug[0m] [0m      val data = ksc.data.getOrElse(throw new IllegalStateException("No keystore builder found!"))[0m
[0m[[0mdebug[0m] [0m      stringBuilder(data)[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def trustStoreBuilder(tsc: TrustStoreConfig): KeyStoreBuilder = {[0m
[0m[[0mdebug[0m] [0m    tsc.filePath.map { f =>[0m
[0m[[0mdebug[0m] [0m      if (tsc.isFileOnClasspath) {[0m
[0m[[0mdebug[0m] [0m        fileOnClasspathBuilder(tsc.storeType, f, None)[0m
[0m[[0mdebug[0m] [0m      } else {[0m
[0m[[0mdebug[0m] [0m        fileBuilder(tsc.storeType, f, None)[0m
[0m[[0mdebug[0m] [0m      }[0m
[0m[[0mdebug[0m] [0m    }.getOrElse {[0m
[0m[[0mdebug[0m] [0m      val data = tsc.data.getOrElse(throw new IllegalStateException("No truststore builder found!"))[0m
[0m[[0mdebug[0m] [0m      stringBuilder(data)[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def fileBuilder(storeType: String, filePath: String, password: Option[Array[Char]]): KeyStoreBuilder = {[0m
[0m[[0mdebug[0m] [0m    new FileBasedKeyStoreBuilder(storeType, filePath, password)[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def fileOnClasspathBuilder(storeType: String, filePath: String, password: Option[Array[Char]]): KeyStoreBuilder = {[0m
[0m[[0mdebug[0m] [0m    new FileOnClasspathBasedKeyStoreBuilder(storeType, filePath, password)[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def stringBuilder(data: String): KeyStoreBuilder = {[0m
[0m[[0mdebug[0m] [0m    new StringBasedKeyStoreBuilder(data)[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Returns true if the keystore should throw an exception as a result of the JSSE bug 6879539, false otherwise.[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def warnOnPKCS12EmptyPasswordBug(ksc: KeyStoreConfig): Boolean =[0m
[0m[[0mdebug[0m] [0m    ksc.storeType.equalsIgnoreCase("pkcs12") && !ksc.password.exists(!_.isEmpty)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Builds a key manager from a keystore, using the KeyManagerFactory.[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def buildKeyManager(ksc: KeyStoreConfig, algorithmChecker: AlgorithmChecker): X509KeyManager = {[0m
[0m[[0mdebug[0m] [0m    val keyStore = try {[0m
[0m[[0mdebug[0m] [0m      keyStoreBuilder(ksc).build()[0m
[0m[[0mdebug[0m] [0m    } catch {[0m
[0m[[0mdebug[0m] [0m      case e: java.lang.ArithmeticException =>[0m
[0m[[0mdebug[0m] [0m        // This bug only exists in 1.6: we'll only check on 1.6 and explain after the exception.[0m
[0m[[0mdebug[0m] [0m        val willExplodeOnEmptyPassword = foldVersion(run16 = warnOnPKCS12EmptyPasswordBug(ksc), runHigher = false)[0m
[0m[[0mdebug[0m] [0m        if (willExplodeOnEmptyPassword) {[0m
[0m[[0mdebug[0m] [0m          val msg =[0m
[0m[[0mdebug[0m] [0m            """You are running JDK 1.6, have a PKCS12 keystore with a null or empty password, and have run into a JSSE bug.[0m
[0m[[0mdebug[0m] [0m              |The bug is closed in JDK 1.8, and backported to 1.7u4 / b13, so upgrading will fix this.[0m
[0m[[0mdebug[0m] [0m              |Please see: http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6879539[0m
[0m[[0mdebug[0m] [0m            """.stripMargin[0m
[0m[[0mdebug[0m] [0m          throw new IllegalStateException(msg, e)[0m
[0m[[0mdebug[0m] [0m        } else {[0m
[0m[[0mdebug[0m] [0m          throw e[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m      case bpe: javax.crypto.BadPaddingException =>[0m
[0m[[0mdebug[0m] [0m        // http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6415637[0m
[0m[[0mdebug[0m] [0m        // http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6974037[0m
[0m[[0mdebug[0m] [0m        // If you run into "Given final block not properly padded", then it's because you entered in the[0m
[0m[[0mdebug[0m] [0m        // wrong password for the keystore, and JSSE tries to decrypt and only then verify the MAC.[0m
[0m[[0mdebug[0m] [0m        throw new SecurityException("Mac verify error: invalid password?", bpe)[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    if (!validateStoreContainsPrivateKeys(ksc, keyStore)) {[0m
[0m[[0mdebug[0m] [0m      logger.warn(s"Client authentication is not possible as there are no private keys found in ${ksc.filePath}")[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    validateStore(keyStore, algorithmChecker)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val password = ksc.password.map(_.toCharArray)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val factory = keyManagerFactory[0m
[0m[[0mdebug[0m] [0m    try {[0m
[0m[[0mdebug[0m] [0m      factory.init(keyStore, password.orNull)[0m
[0m[[0mdebug[0m] [0m    } catch {[0m
[0m[[0mdebug[0m] [0m      case e: UnrecoverableKeyException =>[0m
[0m[[0mdebug[0m] [0m        logger.error(s"Unrecoverable key in keystore $ksc") // TODO log OR rethrow I'd suggest, any reason it's not?[0m
[0m[[0mdebug[0m] [0m        throw new IllegalStateException(e)[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val keyManagers = factory.getKeyManagers[0m
[0m[[0mdebug[0m] [0m    if (keyManagers == null) {[0m
[0m[[0mdebug[0m] [0m      val msg = s"Cannot create key manager with configuration $ksc"[0m
[0m[[0mdebug[0m] [0m      throw new IllegalStateException(msg)[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    // The JSSE implementation only sends back ONE key manager, X509ExtendedKeyManager[0m
[0m[[0mdebug[0m] [0m    keyManagers.head.asInstanceOf[X509KeyManager][0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  // Should anyone have any interest in implementing this feature at all, they can implement this method and[0m
[0m[[0mdebug[0m] [0m  // submit a patch.[0m
[0m[[0mdebug[0m] [0m  def certificateRevocationList(sslConfig: SSLConfigSettings): Option[Seq[CRL]] = {[0m
[0m[[0mdebug[0m] [0m    sslConfig.revocationLists.map {[0m
[0m[[0mdebug[0m] [0m      urls =>[0m
[0m[[0mdebug[0m] [0m        urls.map(generateCRLFromURL)[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def generateCRL(inputStream: InputStream): CRL = {[0m
[0m[[0mdebug[0m] [0m    val cf = CertificateFactory.getInstance("X509")[0m
[0m[[0mdebug[0m] [0m    val crl = cf.generateCRL(inputStream).asInstanceOf[X509CRL][0m
[0m[[0mdebug[0m] [0m    crl[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def generateCRLFromURL(url: URL): CRL = {[0m
[0m[[0mdebug[0m] [0m    val connection = url.openConnection()[0m
[0m[[0mdebug[0m] [0m    connection.setDoInput(true)[0m
[0m[[0mdebug[0m] [0m    connection.setUseCaches(false)[0m
[0m[[0mdebug[0m] [0m    val inStream = new DataInputStream(connection.getInputStream)[0m
[0m[[0mdebug[0m] [0m    try {[0m
[0m[[0mdebug[0m] [0m      generateCRL(inStream)[0m
[0m[[0mdebug[0m] [0m    } finally {[0m
[0m[[0mdebug[0m] [0m      inStream.close()[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def generateCRLFromFile(file: File): CRL = {[0m
[0m[[0mdebug[0m] [0m    val fileStream = new BufferedInputStream(new FileInputStream(file))[0m
[0m[[0mdebug[0m] [0m    val inStream = new DataInputStream(fileStream)[0m
[0m[[0mdebug[0m] [0m    try {[0m
[0m[[0mdebug[0m] [0m      generateCRL(inStream)[0m
[0m[[0mdebug[0m] [0m    } finally {[0m
[0m[[0mdebug[0m] [0m      inStream.close()[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def buildTrustManagerParameters(trustStore: KeyStore,[0m
[0m[[0mdebug[0m] [0m                                  revocationEnabled: Boolean,[0m
[0m[[0mdebug[0m] [0m                                  revocationLists: Option[Seq[CRL]],[0m
[0m[[0mdebug[0m] [0m                                  algorithmChecker: AlgorithmChecker): CertPathTrustManagerParameters = {[0m
[0m[[0mdebug[0m] [0m    import scala.collection.JavaConverters._[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val certSelect: X509CertSelector = new X509CertSelector[0m
[0m[[0mdebug[0m] [0m    val pkixParameters = new PKIXBuilderParameters(trustStore, certSelect)[0m
[0m[[0mdebug[0m] [0m    pkixParameters.setRevocationEnabled(revocationEnabled)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    // For the sake of completeness, set the static revocation list if it exists...[0m
[0m[[0mdebug[0m] [0m    revocationLists.map {[0m
[0m[[0mdebug[0m] [0m      crlList =>[0m
[0m[[0mdebug[0m] [0m        import scala.collection.JavaConverters._[0m
[0m[[0mdebug[0m] [0m        pkixParameters.addCertStore(CertStore.getInstance("Collection", new CollectionCertStoreParameters(crlList.asJavaCollection)))[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    // Add the algorithm checker in here to check the certification path sequence (not including trust anchor)...[0m
[0m[[0mdebug[0m] [0m    val checkers: Seq[PKIXCertPathChecker] = Seq(algorithmChecker)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    // Use the custom cert path checkers we defined...[0m
[0m[[0mdebug[0m] [0m    pkixParameters.setCertPathCheckers(checkers.asJava)[0m
[0m[[0mdebug[0m] [0m    new CertPathTrustManagerParameters(pkixParameters)[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Builds trust managers, using a TrustManagerFactory internally.[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def buildTrustManager(tsc: TrustStoreConfig,[0m
[0m[[0mdebug[0m] [0m                        revocationEnabled: Boolean,[0m
[0m[[0mdebug[0m] [0m                        revocationLists: Option[Seq[CRL]], algorithmChecker: AlgorithmChecker): X509TrustManager = {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val factory = trustManagerFactory[0m
[0m[[0mdebug[0m] [0m    val trustStore = trustStoreBuilder(tsc).build()[0m
[0m[[0mdebug[0m] [0m    validateStore(trustStore, algorithmChecker)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val trustManagerParameters = buildTrustManagerParameters([0m
[0m[[0mdebug[0m] [0m      trustStore,[0m
[0m[[0mdebug[0m] [0m      revocationEnabled,[0m
[0m[[0mdebug[0m] [0m      revocationLists,[0m
[0m[[0mdebug[0m] [0m      algorithmChecker)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    factory.init(trustManagerParameters)[0m
[0m[[0mdebug[0m] [0m    val trustManagers = factory.getTrustManagers[0m
[0m[[0mdebug[0m] [0m    if (trustManagers == null) {[0m
[0m[[0mdebug[0m] [0m      val msg = s"Cannot create trust manager with configuration $tsc"[0m
[0m[[0mdebug[0m] [0m      throw new IllegalStateException(msg)[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    // The JSSE implementation only sends back ONE trust manager, X509TrustManager[0m
[0m[[0mdebug[0m] [0m    trustManagers.head.asInstanceOf[X509TrustManager][0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Validates that a key store (as opposed to a trust store) contains private keys for client authentication.[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def validateStoreContainsPrivateKeys(ksc: KeyStoreConfig, keyStore: KeyStore): Boolean = {[0m
[0m[[0mdebug[0m] [0m    import scala.collection.JavaConverters._[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    // Is there actually a private key being stored in this key store?[0m
[0m[[0mdebug[0m] [0m    val password = ksc.password.map(_.toCharArray).orNull[0m
[0m[[0mdebug[0m] [0m    var containsPrivateKeys = false[0m
[0m[[0mdebug[0m] [0m    for (keyAlias <- keyStore.aliases().asScala) {[0m
[0m[[0mdebug[0m] [0m      val key = keyStore.getKey(keyAlias, password)[0m
[0m[[0mdebug[0m] [0m      key match {[0m
[0m[[0mdebug[0m] [0m        case privateKey: PrivateKey =>[0m
[0m[[0mdebug[0m] [0m          logger.debug(s"validateStoreContainsPrivateKeys: private key found for alias $keyAlias")[0m
[0m[[0mdebug[0m] [0m          containsPrivateKeys = true[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        case otherKey =>[0m
[0m[[0mdebug[0m] [0m          // We want to warn on every failure, as this is not the correct setup for a key store.[0m
[0m[[0mdebug[0m] [0m          val msg = s"validateStoreContainsPrivateKeys: No private key found for alias $keyAlias, it cannot be used for client authentication"[0m
[0m[[0mdebug[0m] [0m          logger.warn(msg)[0m
[0m[[0mdebug[0m] [0m      }[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m    containsPrivateKeys[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Tests each trusted certificate in the store, and warns if the certificate is not valid.  Does not throw[0m
[0m[[0mdebug[0m] [0m   * exceptions.[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def validateStore(store: KeyStore, algorithmChecker: AlgorithmChecker) {[0m
[0m[[0mdebug[0m] [0m    import scala.collection.JavaConverters._[0m
[0m[[0mdebug[0m] [0m    logger.debug(s"validateStore: type = ${store.getType}, size = ${store.size}")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    store.aliases().asScala.foreach {[0m
[0m[[0mdebug[0m] [0m      alias =>[0m
[0m[[0mdebug[0m] [0m        Option(store.getCertificate(alias)).map {[0m
[0m[[0mdebug[0m] [0m          c =>[0m
[0m[[0mdebug[0m] [0m            try {[0m
[0m[[0mdebug[0m] [0m              algorithmChecker.checkKeyAlgorithms(c)[0m
[0m[[0mdebug[0m] [0m            } catch {[0m
[0m[[0mdebug[0m] [0m              case e: CertPathValidatorException =>[0m
[0m[[0mdebug[0m] [0m                logger.warn(s"validateStore: Skipping certificate with weak key size in $alias: " + e.getMessage)[0m
[0m[[0mdebug[0m] [0m                store.deleteEntry(alias)[0m
[0m[[0mdebug[0m] [0m              case e: Exception =>[0m
[0m[[0mdebug[0m] [0m                logger.warn(s"validateStore: Skipping unknown exception $alias: " + e.getMessage)[0m
[0m[[0mdebug[0m] [0m                store.deleteEntry(alias)[0m
[0m[[0mdebug[0m] [0m            }[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mModified text of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/SSLContextBuilder.scala is:[0m
[0m[[0mdebug[0m] [0mNone[0m
[0m[[0mdebug[0m] [0mAbout to create/update header for /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/Algorithms.scala[0m
[0m[[0mdebug[0m] [0mFirst line of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/Algorithms.scala is:[0m
[0m[[0mdebug[0m] [0mText of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/Algorithms.scala is:[0m
[0m[[0mdebug[0m] [0m/*[0m
[0m[[0mdebug[0m] [0m * Copyright (C) 2015 Typesafe Inc. <http://www.typesafe.com>[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mpackage com.typesafe.sslconfig.ssl[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport javax.crypto.SecretKey[0m
[0m[[0mdebug[0m] [0mimport java.security.interfaces._[0m
[0m[[0mdebug[0m] [0mimport javax.crypto.interfaces.DHKey[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport scala.util.parsing.combinator.RegexParsers[0m
[0m[[0mdebug[0m] [0mimport java.security.{ KeyFactory, Key }[0m
[0m[[0mdebug[0m] [0mimport scala.Some[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * This singleton object provides the code needed to check for minimum standards of an X.509 certificate.  Over 95% of trusted leaf certificates and 95% of trusted signing certificates use <a href="http://csrc.nist.gov/publications/nistpubs/800-131A/sp800-131A.pdf">NIST recommended key sizes</a>.  Play supports Java 1.6, which does not have built in <a href="http://sim.ivi.co/2013/11/harness-ssl-and-jsse-key-size-control.html">certificate strength checking</a>, so we roll our own here.[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * The default settings here are based off <a href="">NIST SP 800-57</a>, using <a href="https://wiki.mozilla.org/CA:MD5and1024">Dates for Phasing out MD5-based signatures and 1024-bit moduli</a> as a practical guide.[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * Note that the key sizes are checked on root CA certificates in the trust store.  As the Mozilla document says:[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * <blockquote>The other concern that needs to be addressed is that of RSA1024 being too small a modulus to be robust against faster computers. Unlike a signature algorithm, where only intermediate and end-entity certificates are impacted, fast math means we have to disable or remove all instances of 1024-bit moduli, including the root certificates.</blockquote>[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * Relevant key sizes:[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * <blockquote>[0m
[0m[[0mdebug[0m] [0m * According to NIST SP 800-57 the recommended algorithms and minimum key sizes are as follows:[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * Through 2010 (minimum of 80 bits of strength)[0m
[0m[[0mdebug[0m] [0m * FFC (e.g., DSA, D-H) Minimum: L=1024; N=160[0m
[0m[[0mdebug[0m] [0m * IFC (e.g., RSA) Minimum: k=1024[0m
[0m[[0mdebug[0m] [0m * ECC (e.g. ECDSA) Minimum: f=160[0m
[0m[[0mdebug[0m] [0m * Through 2030 (minimum of 112 bits of strength)[0m
[0m[[0mdebug[0m] [0m * FFC (e.g., DSA, D-H) Minimum: L=2048; N=224[0m
[0m[[0mdebug[0m] [0m * IFC (e.g., RSA) Minimum: k=2048[0m
[0m[[0mdebug[0m] [0m * ECC (e.g. ECDSA) Minimum: f=224[0m
[0m[[0mdebug[0m] [0m * Beyond 2030 (minimum of 128 bits of strength)[0m
[0m[[0mdebug[0m] [0m * FFC (e.g., DSA, D-H) Minimum: L=3072; N=256[0m
[0m[[0mdebug[0m] [0m * IFC (e.g., RSA) Minimum: k=3072[0m
[0m[[0mdebug[0m] [0m * ECC (e.g. ECDSA) Minimum: f=256[0m
[0m[[0mdebug[0m] [0m * </blockquote>[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * Relevant signature algorithms:[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * The known weak signature algorithms are "MD2, MD4, MD5".[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * SHA-1 is considered too weak for new certificates, but is <a href="http://csrc.nist.gov/groups/ST/hash/policy.html">still allowed</a> for verifying old certificates in the chain.  The <a href="https://blogs.oracle.com/xuelei/entry/tls_and_nist_s_policy">TLS and NIST'S Policy on Hash Functions</a> blog post by one of the JSSE authors has more details, in particular the "Put it into practice" section.[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0mobject Algorithms {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Disabled signature algorithms are applied to signed certificates in a certificate chain, not including CA certs.[0m
[0m[[0mdebug[0m] [0m   *[0m
[0m[[0mdebug[0m] [0m   * @return "MD2, MD4, MD5"[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def disabledSignatureAlgorithms: String = "MD2, MD4, MD5"[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Disabled key algorithms are applied to all certificates, including the root CAs.[0m
[0m[[0mdebug[0m] [0m   *[0m
[0m[[0mdebug[0m] [0m   * @return "RSA keySize < 2048, DSA keySize < 2048, EC keySize < 224"[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def disabledKeyAlgorithms: String = "RSA keySize < 2048, DSA keySize < 2048, EC keySize < 224"[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Returns the keySize of the given key, or None if no key exists.[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def keySize(key: java.security.Key): Option[Int] = {[0m
[0m[[0mdebug[0m] [0m    key match {[0m
[0m[[0mdebug[0m] [0m      case sk: SecretKey =>[0m
[0m[[0mdebug[0m] [0m        if ((sk.getFormat == "RAW") && sk.getEncoded != null) {[0m
[0m[[0mdebug[0m] [0m          Some(sk.getEncoded.length * 8)[0m
[0m[[0mdebug[0m] [0m        } else {[0m
[0m[[0mdebug[0m] [0m          None[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m      case pubk: RSAKey =>[0m
[0m[[0mdebug[0m] [0m        Some(pubk.getModulus.bitLength)[0m
[0m[[0mdebug[0m] [0m      case pubk: ECKey =>[0m
[0m[[0mdebug[0m] [0m        Some(pubk.getParams.getOrder.bitLength())[0m
[0m[[0mdebug[0m] [0m      case pubk: DSAKey =>[0m
[0m[[0mdebug[0m] [0m        Some(pubk.getParams.getP.bitLength)[0m
[0m[[0mdebug[0m] [0m      case pubk: DHKey =>[0m
[0m[[0mdebug[0m] [0m        Some(pubk.getParams.getP.bitLength)[0m
[0m[[0mdebug[0m] [0m      case pubk: Key =>[0m
[0m[[0mdebug[0m] [0m        val translatedKey = translateKey(pubk)[0m
[0m[[0mdebug[0m] [0m        keySize(translatedKey)[0m
[0m[[0mdebug[0m] [0m      case unknownKey =>[0m
[0m[[0mdebug[0m] [0m        try {[0m
[0m[[0mdebug[0m] [0m          val lengthMethod = unknownKey.getClass.getMethod("length")[0m
[0m[[0mdebug[0m] [0m          val l = lengthMethod.invoke(unknownKey).asInstanceOf[Integer][0m
[0m[[0mdebug[0m] [0m          if (l >= 0) Some(l) else None[0m
[0m[[0mdebug[0m] [0m        } catch {[0m
[0m[[0mdebug[0m] [0m          case _: Throwable =>[0m
[0m[[0mdebug[0m] [0m            throw new IllegalStateException(s"unknown key ${key.getClass.getName}")[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m      // None[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def getKeyAlgorithmName(pubk: Key): String = {[0m
[0m[[0mdebug[0m] [0m    val name = pubk.getAlgorithm[0m
[0m[[0mdebug[0m] [0m    if (name == "DH") "DiffieHellman" else name[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def translateKey(pubk: Key): Key = {[0m
[0m[[0mdebug[0m] [0m    val keyAlgName = getKeyAlgorithmName(pubk)[0m
[0m[[0mdebug[0m] [0m    foldVersion([0m
[0m[[0mdebug[0m] [0m      run16 = {[0m
[0m[[0mdebug[0m] [0m        keyAlgName match {[0m
[0m[[0mdebug[0m] [0m          case "EC" =>[0m
[0m[[0mdebug[0m] [0m            // If we are on 1.6, then we can't use the EC factory and have to pull it directly.[0m
[0m[[0mdebug[0m] [0m            translateECKey(pubk)[0m
[0m[[0mdebug[0m] [0m          case _ =>[0m
[0m[[0mdebug[0m] [0m            val keyFactory = KeyFactory.getInstance(keyAlgName)[0m
[0m[[0mdebug[0m] [0m            keyFactory.translateKey(pubk)[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m      },[0m
[0m[[0mdebug[0m] [0m      runHigher = {[0m
[0m[[0mdebug[0m] [0m        val keyFactory = KeyFactory.getInstance(keyAlgName)[0m
[0m[[0mdebug[0m] [0m        keyFactory.translateKey(pubk)[0m
[0m[[0mdebug[0m] [0m      }[0m
[0m[[0mdebug[0m] [0m    )[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def translateECKey(pubk: Key): Key = {[0m
[0m[[0mdebug[0m] [0m    val keyFactory = Thread.currentThread().getContextClassLoader.loadClass("sun.security.ec.ECKeyFactory")[0m
[0m[[0mdebug[0m] [0m    val method = keyFactory.getMethod("toECKey", classOf[java.security.Key])[0m
[0m[[0mdebug[0m] [0m    method.invoke(null, pubk) match {[0m
[0m[[0mdebug[0m] [0m      case e: ECPublicKey =>[0m
[0m[[0mdebug[0m] [0m        e[0m
[0m[[0mdebug[0m] [0m      case e: ECPrivateKey =>[0m
[0m[[0mdebug[0m] [0m        e[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Decompose the standard algorithm name into sub-elements.[0m
[0m[[0mdebug[0m] [0m   * <p/>[0m
[0m[[0mdebug[0m] [0m   * For example, we need to decompose "SHA1WithRSA" into "SHA1" and "RSA"[0m
[0m[[0mdebug[0m] [0m   * so that we can check the "SHA1" and "RSA" algorithm constraints[0m
[0m[[0mdebug[0m] [0m   * separately.[0m
[0m[[0mdebug[0m] [0m   * <p/>[0m
[0m[[0mdebug[0m] [0m   * Please override the method if need to support more name pattern.[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def decomposes(algorithm: String): Set[String] = {[0m
[0m[[0mdebug[0m] [0m    if (algorithm == null || algorithm.length == 0) {[0m
[0m[[0mdebug[0m] [0m      throw new IllegalArgumentException("Null or blank algorithm found!")[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val withAndPattern = new scala.util.matching.Regex("(?i)with|and")[0m
[0m[[0mdebug[0m] [0m    val tokens: Array[String] = "/".r.split(algorithm)[0m
[0m[[0mdebug[0m] [0m    val elements = (for {[0m
[0m[[0mdebug[0m] [0m      t <- tokens[0m
[0m[[0mdebug[0m] [0m      name <- withAndPattern.split(t)[0m
[0m[[0mdebug[0m] [0m    } yield {[0m
[0m[[0mdebug[0m] [0m      name[0m
[0m[[0mdebug[0m] [0m    }).toSet[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    if (elements.contains("SHA1") && !elements.contains("SHA-1")) {[0m
[0m[[0mdebug[0m] [0m      elements + "SHA-1"[0m
[0m[[0mdebug[0m] [0m    } else if (elements.contains("SHA-1") && !elements.contains("SHA1")) {[0m
[0m[[0mdebug[0m] [0m      elements + "SHA1"[0m
[0m[[0mdebug[0m] [0m    } else {[0m
[0m[[0mdebug[0m] [0m      elements[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0msealed abstract class ExpressionSymbol {[0m
[0m[[0mdebug[0m] [0m  def matches(actualKeySize: Int): Boolean[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mcase class LessThan(x: Int) extends ExpressionSymbol {[0m
[0m[[0mdebug[0m] [0m  def matches(actualKeySize: Int): Boolean = actualKeySize < x[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  override def toString = " keySize < " + x[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mcase class LessThanOrEqual(x: Int) extends ExpressionSymbol {[0m
[0m[[0mdebug[0m] [0m  def matches(actualKeySize: Int): Boolean = actualKeySize <= x[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  override def toString = " keySize <= " + x[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mcase class NotEqual(x: Int) extends ExpressionSymbol {[0m
[0m[[0mdebug[0m] [0m  def matches(actualKeySize: Int): Boolean = actualKeySize != x[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  override def toString = " keySize != " + x[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mcase class Equal(x: Int) extends ExpressionSymbol {[0m
[0m[[0mdebug[0m] [0m  def matches(actualKeySize: Int): Boolean = actualKeySize == x[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  override def toString = " keySize ==" + x[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mcase class MoreThan(x: Int) extends ExpressionSymbol {[0m
[0m[[0mdebug[0m] [0m  def matches(actualKeySize: Int): Boolean = actualKeySize > x[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  override def toString = " keySize > " + x[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mcase class MoreThanOrEqual(x: Int) extends ExpressionSymbol {[0m
[0m[[0mdebug[0m] [0m  def matches(actualKeySize: Int): Boolean = actualKeySize >= x[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  override def toString = " keySize >= " + x[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mcase class AlgorithmConstraint(algorithm: String, constraint: Option[ExpressionSymbol] = None) {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Returns true only if the algorithm matches.  Useful for signature algorithms where we don't care about key size.[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def matches(algorithm: String): Boolean = {[0m
[0m[[0mdebug[0m] [0m    this.algorithm.equalsIgnoreCase(algorithm)[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Returns true if the algorithm name matches, and if there's a keySize constraint, will match on that as well.[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def matches(algorithm: String, keySize: Int): Boolean = {[0m
[0m[[0mdebug[0m] [0m    if (!matches(algorithm)) {[0m
[0m[[0mdebug[0m] [0m      return false[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    constraint match {[0m
[0m[[0mdebug[0m] [0m      case Some(expression) =>[0m
[0m[[0mdebug[0m] [0m        expression.matches(keySize)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m      case None =>[0m
[0m[[0mdebug[0m] [0m        true[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  override def toString = {[0m
[0m[[0mdebug[0m] [0m    algorithm + constraint.getOrElse("")[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * Parser based on the jdk.certpath.disabledAlgorithm BNF.[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * @see http://sim.ivi.co/2011/07/java-se-7-release-security-enhancements.html[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0mobject AlgorithmConstraintsParser extends RegexParsers {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  import scala.language.postfixOps[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def apply(input: String): AlgorithmConstraint = parseAll(expression, input) match {[0m
[0m[[0mdebug[0m] [0m    case Success(result, _) =>[0m
[0m[[0mdebug[0m] [0m      result[0m
[0m[[0mdebug[0m] [0m    case NoSuccess(message, _) =>[0m
[0m[[0mdebug[0m] [0m      throw new IllegalArgumentException(s"Cannot parse string $input: $message")[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def line: Parser[List[AlgorithmConstraint]] = repsep(expression, ",")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def expression: Parser[AlgorithmConstraint] = algorithm ~ (keySizeConstraint ?) ^^ {[0m
[0m[[0mdebug[0m] [0m    case algorithm ~ Some(constraint) =>[0m
[0m[[0mdebug[0m] [0m      AlgorithmConstraint(algorithm, Some(constraint))[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    case algorithm ~ None =>[0m
[0m[[0mdebug[0m] [0m      AlgorithmConstraint(algorithm, None)[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def keySizeConstraint: Parser[ExpressionSymbol] = "keySize" ~> operator ~ decimalInteger ^^ {[0m
[0m[[0mdebug[0m] [0m    case "<=" ~ decimal =>[0m
[0m[[0mdebug[0m] [0m      LessThanOrEqual(decimal)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    case "<" ~ decimal =>[0m
[0m[[0mdebug[0m] [0m      LessThan(decimal)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    case "==" ~ decimal =>[0m
[0m[[0mdebug[0m] [0m      Equal(decimal)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    case "!=" ~ decimal =>[0m
[0m[[0mdebug[0m] [0m      NotEqual(decimal)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    case ">=" ~ decimal =>[0m
[0m[[0mdebug[0m] [0m      MoreThanOrEqual(decimal)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    case ">" ~ decimal =>[0m
[0m[[0mdebug[0m] [0m      MoreThan(decimal)[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def operator: Parser[String] = "<=" | "<" | "==" | "!=" | ">=" | ">"[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def decimalInteger: Parser[Int] = """\d+""".r ^^ {[0m
[0m[[0mdebug[0m] [0m    f => f.toInt[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def algorithm: Parser[String] = """\w+""".r ^^ {[0m
[0m[[0mdebug[0m] [0m    f => f.toString[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mModified text of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/Algorithms.scala is:[0m
[0m[[0mdebug[0m] [0mNone[0m
[0m[[0mdebug[0m] [0mAbout to create/update header for /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/CompositeCertificateException.scala[0m
[0m[[0mdebug[0m] [0mFirst line of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/CompositeCertificateException.scala is:[0m
[0m[[0mdebug[0m] [0mText of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/CompositeCertificateException.scala is:[0m
[0m[[0mdebug[0m] [0m/*[0m
[0m[[0mdebug[0m] [0m * Copyright (C) 2015 Typesafe Inc. <http://www.typesafe.com>[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mpackage com.typesafe.sslconfig.ssl[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport java.security.cert.CertificateException[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * A certificate exception that contains underlying exceptions.[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0mclass CompositeCertificateException(msg: String, val throwables: Array[Throwable]) extends CertificateException(msg) {[0m
[0m[[0mdebug[0m] [0m  def getSourceExceptions: Array[Throwable] = throwables[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mobject CompositeCertificateException {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def unwrap(e: Throwable)(block: Throwable => Unit) = {[0m
[0m[[0mdebug[0m] [0m    var cause: Throwable = e[0m
[0m[[0mdebug[0m] [0m    while (cause != null) {[0m
[0m[[0mdebug[0m] [0m      cause match {[0m
[0m[[0mdebug[0m] [0m        case composite: CompositeCertificateException =>[0m
[0m[[0mdebug[0m] [0m          composite.getSourceExceptions.foreach { sourceException =>[0m
[0m[[0mdebug[0m] [0m            block(sourceException)[0m
[0m[[0mdebug[0m] [0m          }[0m
[0m[[0mdebug[0m] [0m        case other =>[0m
[0m[[0mdebug[0m] [0m          block(other)[0m
[0m[[0mdebug[0m] [0m      }[0m
[0m[[0mdebug[0m] [0m      cause = cause.getCause[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mModified text of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/CompositeCertificateException.scala is:[0m
[0m[[0mdebug[0m] [0mNone[0m
[0m[[0mdebug[0m] [0mAbout to create/update header for /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/Protocols.scala[0m
[0m[[0mdebug[0m] [0mFirst line of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/Protocols.scala is:[0m
[0m[[0mdebug[0m] [0mText of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/Protocols.scala is:[0m
[0m[[0mdebug[0m] [0m/*[0m
[0m[[0mdebug[0m] [0m * Copyright (C) 2015 Typesafe Inc. <http://www.typesafe.com>[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mpackage com.typesafe.sslconfig.ssl[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mobject Protocols {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Protocols which are known to be insecure.[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  val deprecatedProtocols = Set("SSL", "SSLv2Hello", "SSLv3")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  val recommendedProtocols = Array("TLSv1.2", "TLSv1.1", "TLSv1")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  // Use 1.2 as a default in 1.7, use 1.0 in 1.6[0m
[0m[[0mdebug[0m] [0m  // https://docs.fedoraproject.org/en-US/Fedora_Security_Team//html/Defensive_Coding/sect-Defensive_Coding-TLS-Client-OpenJDK.html[0m
[0m[[0mdebug[0m] [0m  def recommendedProtocol = foldVersion(run16 = "TLSv1", runHigher = "TLSv1.2")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mModified text of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/Protocols.scala is:[0m
[0m[[0mdebug[0m] [0mNone[0m
[0m[[0mdebug[0m] [0mAbout to create/update header for /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/SystemConfiguration.scala[0m
[0m[[0mdebug[0m] [0mFirst line of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/SystemConfiguration.scala is:[0m
[0m[[0mdebug[0m] [0mText of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/SystemConfiguration.scala is:[0m
[0m[[0mdebug[0m] [0m/*[0m
[0m[[0mdebug[0m] [0m * Copyright (C) 2015 Typesafe Inc. <http://www.typesafe.com>[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mpackage com.typesafe.sslconfig.ssl[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport java.security.Security[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport com.typesafe.sslconfig.util.{ LoggerFactory, NoDepsLogger }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * Configures global system properties on the JSSE implementation, if defined.[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * WARNING: This class sets system properties to configure JSSE code which typically uses static initialization on[0m
[0m[[0mdebug[0m] [0m * load.  Because of this, if classes are loaded in BEFORE this code has a chance to operate, you may find that this[0m
[0m[[0mdebug[0m] [0m * code works inconsistently.  The solution is to set the system properties on the command line explicitly (or in the[0m
[0m[[0mdebug[0m] [0m * case of "ocsp.enable", in the security property file).[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0mclass SystemConfiguration(mkLogger: LoggerFactory) {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  val logger = mkLogger(getClass)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def configure(config: SSLConfigSettings) {[0m
[0m[[0mdebug[0m] [0m    config.loose.allowUnsafeRenegotiation.foreach(configureUnsafeRenegotiation)[0m
[0m[[0mdebug[0m] [0m    config.loose.allowLegacyHelloMessages.foreach(configureAllowLegacyHelloMessages)[0m
[0m[[0mdebug[0m] [0m    config.checkRevocation.foreach(configureCheckRevocation)[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def configureUnsafeRenegotiation(allowUnsafeRenegotiation: Boolean) {[0m
[0m[[0mdebug[0m] [0m    System.setProperty("sun.security.ssl.allowUnsafeRenegotiation", allowUnsafeRenegotiation.toString)[0m
[0m[[0mdebug[0m] [0m    logger.debug(s"configureUnsafeRenegotiation: sun.security.ssl.allowUnsafeRenegotiation = ${allowUnsafeRenegotiation.toString}")[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def configureAllowLegacyHelloMessages(allowLegacyHelloMessages: Boolean) {[0m
[0m[[0mdebug[0m] [0m    System.setProperty("sun.security.ssl.allowLegacyHelloMessages", allowLegacyHelloMessages.toString)[0m
[0m[[0mdebug[0m] [0m    logger.debug(s"configureAllowLegacyHelloMessages: sun.security.ssl.allowLegacyHelloMessages = ${allowLegacyHelloMessages.toString}")[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def configureCheckRevocation(checkRevocation: Boolean) {[0m
[0m[[0mdebug[0m] [0m    // http://docs.oracle.com/javase/8/docs/technotes/guides/security/certpath/CertPathProgGuide.html#AppC[0m
[0m[[0mdebug[0m] [0m    // https://blogs.oracle.com/xuelei/entry/enable_ocsp_checking[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    // 1.7: PXIXCertPathValidator.populateVariables, it is dynamic so no override needed.[0m
[0m[[0mdebug[0m] [0m    Security.setProperty("ocsp.enable", checkRevocation.toString)[0m
[0m[[0mdebug[0m] [0m    logger.debug(s"configureCheckRevocation: ocsp.enable = ${checkRevocation.toString}")[0m
[0m[[0mdebug[0m] [0m    System.setProperty("com.sun.security.enableCRLDP", checkRevocation.toString)[0m
[0m[[0mdebug[0m] [0m    logger.debug(s"configureCheckRevocation: com.sun.security.enableCRLDP = ${checkRevocation.toString}")[0m
[0m[[0mdebug[0m] [0m    System.setProperty("com.sun.net.ssl.checkRevocation", checkRevocation.toString)[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * For use in testing.[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def clearProperties() {[0m
[0m[[0mdebug[0m] [0m    Security.setProperty("ocsp.enable", "false")[0m
[0m[[0mdebug[0m] [0m    System.clearProperty("com.sun.security.enableCRLDP")[0m
[0m[[0mdebug[0m] [0m    System.clearProperty("com.sun.net.ssl.checkRevocation")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    System.clearProperty("sun.security.ssl.allowLegacyHelloMessages")[0m
[0m[[0mdebug[0m] [0m    System.clearProperty("sun.security.ssl.allowUnsafeRenegotiation")[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mModified text of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/SystemConfiguration.scala is:[0m
[0m[[0mdebug[0m] [0mNone[0m
[0m[[0mdebug[0m] [0mAbout to create/update header for /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/package.scala[0m
[0m[[0mdebug[0m] [0mFirst line of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/package.scala is:[0m
[0m[[0mdebug[0m] [0mText of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/package.scala is:[0m
[0m[[0mdebug[0m] [0m/*[0m
[0m[[0mdebug[0m] [0m * Copyright (C) 2015 Typesafe Inc. <http://www.typesafe.com>[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mpackage com.typesafe.sslconfig[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport java.security.cert.{ PKIXCertPathValidatorResult, CertPathValidatorResult, Certificate, X509Certificate }[0m
[0m[[0mdebug[0m] [0mimport scala.util.Properties.{ isJavaAtLeast, javaVmName }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mpackage object ssl {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  import scala.language.implicitConversions[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  implicit def certificate2X509Certificate(cert: java.security.cert.Certificate): X509Certificate = {[0m
[0m[[0mdebug[0m] [0m    cert.asInstanceOf[X509Certificate][0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  implicit def arrayCertsToListCerts(chain: Array[Certificate]): java.util.List[Certificate] = {[0m
[0m[[0mdebug[0m] [0m    import scala.collection.JavaConverters._[0m
[0m[[0mdebug[0m] [0m    chain.toList.asJava[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  implicit def certResult2PKIXResult(result: CertPathValidatorResult): PKIXCertPathValidatorResult = {[0m
[0m[[0mdebug[0m] [0m    result.asInstanceOf[PKIXCertPathValidatorResult][0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def debugChain(chain: Array[X509Certificate]): Seq[String] = {[0m
[0m[[0mdebug[0m] [0m    chain.map {[0m
[0m[[0mdebug[0m] [0m      cert =>[0m
[0m[[0mdebug[0m] [0m        s"${cert.getSubjectDN.getName}"[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def foldVersion[T](run16: => T, runHigher: => T): T = {[0m
[0m[[0mdebug[0m] [0m    System.getProperty("java.specification.version") match {[0m
[0m[[0mdebug[0m] [0m      case "1.6" =>[0m
[0m[[0mdebug[0m] [0m        run16[0m
[0m[[0mdebug[0m] [0m      case higher =>[0m
[0m[[0mdebug[0m] [0m        runHigher[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def isOpenJdk: Boolean = javaVmName contains "OpenJDK"[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  // NOTE: Some SSL classes in OpenJDK 6 are in the same locations as JDK 7[0m
[0m[[0mdebug[0m] [0m  def foldRuntime[T](older: => T, newer: => T): T = {[0m
[0m[[0mdebug[0m] [0m    if (isJavaAtLeast("1.7") || isOpenJdk) newer else older[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mModified text of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/package.scala is:[0m
[0m[[0mdebug[0m] [0mNone[0m
[0m[[0mdebug[0m] [0mAbout to create/update header for /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/AlgorithmChecker.scala[0m
[0m[[0mdebug[0m] [0mFirst line of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/AlgorithmChecker.scala is:[0m
[0m[[0mdebug[0m] [0mText of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/AlgorithmChecker.scala is:[0m
[0m[[0mdebug[0m] [0m/*[0m
[0m[[0mdebug[0m] [0m * Copyright (C) 2015 Typesafe Inc. <http://www.typesafe.com>[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mpackage com.typesafe.sslconfig.ssl[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport java.security.cert._[0m
[0m[[0mdebug[0m] [0mimport java.text.SimpleDateFormat[0m
[0m[[0mdebug[0m] [0mimport java.util.{ Date, GregorianCalendar, Calendar }[0m
[0m[[0mdebug[0m] [0mimport javax.naming.InvalidNameException[0m
[0m[[0mdebug[0m] [0mimport javax.naming.ldap.{ LdapName, Rdn }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport com.typesafe.sslconfig.util.{ LoggerFactory, NoDepsLogger }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport scala.collection.JavaConverters._[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * Looks for disabled algorithms in the certificate.  This is because some certificates are signed with[0m
[0m[[0mdebug[0m] [0m * forgable hashes such as MD2 or MD5, so we can't be certain of their authenticity.[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * This class is needed because the JDK 1.6 Algorithm checker doesn't give us any way to customize the list of[0m
[0m[[0mdebug[0m] [0m * disabled algorithms, and we need to be able to support that.[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * Also note that we need to check the trust anchor for disabled key sizes, and the CertPath explicitly removes[0m
[0m[[0mdebug[0m] [0m * the trust anchor from the chain of certificates.  This means we need to check the trust anchor explicitly in the[0m
[0m[[0mdebug[0m] [0m * through the CompositeTrustManager.[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0mclass AlgorithmChecker(mkLogger: LoggerFactory, val signatureConstraints: Set[AlgorithmConstraint], val keyConstraints: Set[AlgorithmConstraint]) extends PKIXCertPathChecker {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  private val logger = mkLogger(getClass)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  private val signatureConstraintsMap: Map[String, AlgorithmConstraint] = {[0m
[0m[[0mdebug[0m] [0m    for (c <- signatureConstraints.iterator) yield {[0m
[0m[[0mdebug[0m] [0m      c.algorithm -> c[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }.toMap[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  private val keyConstraintsMap: Map[String, AlgorithmConstraint] = {[0m
[0m[[0mdebug[0m] [0m    for (c <- keyConstraints.iterator) yield {[0m
[0m[[0mdebug[0m] [0m      c.algorithm -> c[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }.toMap[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def isForwardCheckingSupported: Boolean = false[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def getSupportedExtensions: java.util.Set[String] = java.util.Collections.emptySet()[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def init(forward: Boolean) {[0m
[0m[[0mdebug[0m] [0m    logger.debug(s"init: forward = $forward")[0m
[0m[[0mdebug[0m] [0m    // forward is from target to most-trusted CA[0m
[0m[[0mdebug[0m] [0m    // backwards is from most-trusted CA to target, which means we get the root CA first.[0m
[0m[[0mdebug[0m] [0m    if (forward) {[0m
[0m[[0mdebug[0m] [0m      throw new CertPathValidatorException("Forward checking not supported")[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def findSignatureConstraint(algorithm: String): Option[AlgorithmConstraint] = {[0m
[0m[[0mdebug[0m] [0m    signatureConstraintsMap.get(algorithm)[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def findKeyConstraint(algorithm: String): Option[AlgorithmConstraint] = {[0m
[0m[[0mdebug[0m] [0m    keyConstraintsMap.get(algorithm)[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Checks for signature algorithms in the certificate and throws CertPathValidatorException if matched.[0m
[0m[[0mdebug[0m] [0m   *[0m
[0m[[0mdebug[0m] [0m   * @param x509Cert[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def checkSignatureAlgorithms(x509Cert: X509Certificate): Unit = {[0m
[0m[[0mdebug[0m] [0m    val sigAlgName = x509Cert.getSigAlgName[0m
[0m[[0mdebug[0m] [0m    val sigAlgorithms = Algorithms.decomposes(sigAlgName)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    logger.debug(s"checkSignatureAlgorithms: sigAlgName = $sigAlgName, sigAlgName = $sigAlgName, sigAlgorithms = $sigAlgorithms")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    for (a <- sigAlgorithms) {[0m
[0m[[0mdebug[0m] [0m      findSignatureConstraint(a).foreach { constraint =>[0m
[0m[[0mdebug[0m] [0m        if (constraint.matches(a)) {[0m
[0m[[0mdebug[0m] [0m          logger.debug(s"checkSignatureAlgorithms: x509Cert = $x509Cert failed on constraint $constraint")[0m
[0m[[0mdebug[0m] [0m          val msg = s"Certificate failed: $a matched constraint $constraint"[0m
[0m[[0mdebug[0m] [0m          throw new CertPathValidatorException(msg)[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m      }[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Checks for key algorithms in the certificate and throws CertPathValidatorException if matched.[0m
[0m[[0mdebug[0m] [0m   *[0m
[0m[[0mdebug[0m] [0m   * @param x509Cert[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def checkKeyAlgorithms(x509Cert: X509Certificate): Unit = {[0m
[0m[[0mdebug[0m] [0m    val key = x509Cert.getPublicKey[0m
[0m[[0mdebug[0m] [0m    val keyAlgorithmName = key.getAlgorithm[0m
[0m[[0mdebug[0m] [0m    val keySize = Algorithms.keySize(key).getOrElse(throw new IllegalStateException(s"No keySize found for $key"))[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val keyAlgorithms = Algorithms.decomposes(keyAlgorithmName)[0m
[0m[[0mdebug[0m] [0m    logger.debug(s"checkKeyAlgorithms: keyAlgorithmName = $keyAlgorithmName, keySize = $keySize, keyAlgorithms = $keyAlgorithms")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    for (a <- keyAlgorithms) {[0m
[0m[[0mdebug[0m] [0m      findKeyConstraint(a).foreach {[0m
[0m[[0mdebug[0m] [0m        constraint =>[0m
[0m[[0mdebug[0m] [0m          if (constraint.matches(a, keySize)) {[0m
[0m[[0mdebug[0m] [0m            val certName = x509Cert.getSubjectX500Principal.getName[0m
[0m[[0mdebug[0m] [0m            logger.debug(s"""checkKeyAlgorithms: cert = "$certName" failed on constraint $constraint, algorithm = $a, keySize = $keySize""")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m            val msg = s"""Certificate failed: cert = "$certName" failed on constraint $constraint, algorithm = $a, keySize = $keySize"""[0m
[0m[[0mdebug[0m] [0m            throw new CertPathValidatorException(msg)[0m
[0m[[0mdebug[0m] [0m          }[0m
[0m[[0mdebug[0m] [0m      }[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Checks the algorithms in the given certificate.  Note that this implementation skips signature checking in a[0m
[0m[[0mdebug[0m] [0m   * root certificate, as a trusted root cert by definition is in the trust store and doesn't need to be signed.[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def check(cert: Certificate, unresolvedCritExts: java.util.Collection[String]) {[0m
[0m[[0mdebug[0m] [0m    cert match {[0m
[0m[[0mdebug[0m] [0m      case x509Cert: X509Certificate =>[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        val commonName = getCommonName(x509Cert)[0m
[0m[[0mdebug[0m] [0m        val subAltNames = x509Cert.getSubjectAlternativeNames[0m
[0m[[0mdebug[0m] [0m        val certName = x509Cert.getSubjectX500Principal.getName[0m
[0m[[0mdebug[0m] [0m        if (logger.isDebugEnabled) {[0m
[0m[[0mdebug[0m] [0m          val expirationDate = x509Cert.getNotAfter.getTime[0m
[0m[[0mdebug[0m] [0m          val isoFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'") // reminder for scala people, that one's not thread-safe...[0m
[0m[[0mdebug[0m] [0m          logger.debug(s"check: checking certificate commonName = $commonName, subjAltName = $subAltNames, certName = $certName, expirationDate = ${isoFormat.format(expirationDate)}")[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        sunsetSHA1SignatureAlgorithm(x509Cert)[0m
[0m[[0mdebug[0m] [0m        checkSignatureAlgorithms(x509Cert)[0m
[0m[[0mdebug[0m] [0m        checkKeyAlgorithms(x509Cert)[0m
[0m[[0mdebug[0m] [0m      case _ =>[0m
[0m[[0mdebug[0m] [0m        throw new UnsupportedOperationException("check only works with x509 certificates!")[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Logs an info or warning message to sunset a SHA-1 certificate, based on[0m
[0m[[0mdebug[0m] [0m   * <a href="http://googleonlinesecurity.blogspot.com/2014/09/gradually-sunsetting-sha-1.html">Google's recommendations</a>.[0m
[0m[[0mdebug[0m] [0m   *[0m
[0m[[0mdebug[0m] [0m   * @param x509Cert[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def sunsetSHA1SignatureAlgorithm(x509Cert: X509Certificate): Unit = {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val sigAlgName = x509Cert.getSigAlgName[0m
[0m[[0mdebug[0m] [0m    val sigAlgorithms = Algorithms.decomposes(sigAlgName)[0m
[0m[[0mdebug[0m] [0m    if (sigAlgorithms.contains("SHA1") || sigAlgorithms.contains("SHA-1")) {[0m
[0m[[0mdebug[0m] [0m      // https://github.com/playframework/playframework/issues/4241[0m
[0m[[0mdebug[0m] [0m      //[0m
[0m[[0mdebug[0m] [0m      // Sites with end-entity certificates that expire between 1 June 2016 to 31 December 2016 (inclusive),[0m
[0m[[0mdebug[0m] [0m      // and which include a SHA-1-based signature as part of the certificate chain, will be treated as â€œsecure, but with minor errorsâ€.[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m      // TODO use Java 8 time once we can[0m
[0m[[0mdebug[0m] [0m      // val june2016 = new DateTime(2016, 6, 1, 0, 0, 0, 0)[0m
[0m[[0mdebug[0m] [0m      // val december2016 = new DateTime(2016, 12, 31, 0, 0, 0, 0)[0m
[0m[[0mdebug[0m] [0m      // val secureInterval = new Interval(june2016, december2016)[0m
[0m[[0mdebug[0m] [0m      // val expirationDate = new DateTime(x509Cert.getNotAfter.getTime)[0m
[0m[[0mdebug[0m] [0m      // log warning if expiration between those two[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m      val june2016 = new GregorianCalendar(2016, 6, 1, 0, 0, 0)[0m
[0m[[0mdebug[0m] [0m      val december2016 = new GregorianCalendar(2016, 12, 31, 0, 0, 0)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m      val expirationDate = new GregorianCalendar()[0m
[0m[[0mdebug[0m] [0m      expirationDate.setTime(new Date(x509Cert.getNotAfter.getTime))[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m      // expiration date between those two above[0m
[0m[[0mdebug[0m] [0m      if (expirationDate.after(june2016) && expirationDate.before(december2016)) {[0m
[0m[[0mdebug[0m] [0m        infoOnSunset(x509Cert, expirationDate)[0m
[0m[[0mdebug[0m] [0m      }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m      // Sites with end-entity certificates that expire on or after 1 January 2017, and which include[0m
[0m[[0mdebug[0m] [0m      // a SHA-1-based signature as part of the certificate chain, will be treated as[0m
[0m[[0mdebug[0m] [0m      // â€œneutral, lacking securityâ€.[0m
[0m[[0mdebug[0m] [0m      val january2017 = new GregorianCalendar(2017, 1, 1, 0, 0, 0)[0m
[0m[[0mdebug[0m] [0m      if (january2017.equals(expirationDate) || january2017.before(expirationDate)) {[0m
[0m[[0mdebug[0m] [0m        warnOnSunset(x509Cert, expirationDate)[0m
[0m[[0mdebug[0m] [0m      }[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def infoOnSunset(x509Cert: X509Certificate, expirationDate: GregorianCalendar): Unit = {[0m
[0m[[0mdebug[0m] [0m    val certName = x509Cert.getSubjectX500Principal.getName[0m
[0m[[0mdebug[0m] [0m    logger.info(s"Certificate $certName uses SHA-1 and expires $expirationDate: this certificate expires soon, but SHA-1 is being sunsetted.")[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def warnOnSunset(x509Cert: X509Certificate, expirationDate: GregorianCalendar): Unit = {[0m
[0m[[0mdebug[0m] [0m    val certName = x509Cert.getSubjectX500Principal.getName[0m
[0m[[0mdebug[0m] [0m    logger.warn(s"Certificate $certName uses SHA-1 and expires $expirationDate: SHA-1 cannot be considered secure and this certificate should be replaced.")[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Useful way to get certificate info without getting spammed with data.[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def getCommonName(cert: X509Certificate) = {[0m
[0m[[0mdebug[0m] [0m    // http://stackoverflow.com/a/18174689/5266[0m
[0m[[0mdebug[0m] [0m    try {[0m
[0m[[0mdebug[0m] [0m      val ldapName = new LdapName(cert.getSubjectX500Principal.getName)[0m
[0m[[0mdebug[0m] [0m      /*[0m
[0m[[0mdebug[0m] [0m       * Looking for the "most specific CN" (i.e. the last).[0m
[0m[[0mdebug[0m] [0m       */[0m
[0m[[0mdebug[0m] [0m      var cn: String = null[0m
[0m[[0mdebug[0m] [0m      for (rdn: Rdn <- ldapName.getRdns.asScala) {[0m
[0m[[0mdebug[0m] [0m        if ("CN".equalsIgnoreCase(rdn.getType)) {[0m
[0m[[0mdebug[0m] [0m          cn = rdn.getValue.toString[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m      }[0m
[0m[[0mdebug[0m] [0m      cn[0m
[0m[[0mdebug[0m] [0m    } catch {[0m
[0m[[0mdebug[0m] [0m      case e: InvalidNameException =>[0m
[0m[[0mdebug[0m] [0m        null[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mModified text of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/AlgorithmChecker.scala is:[0m
[0m[[0mdebug[0m] [0mNone[0m
[0m[[0mdebug[0m] [0mAbout to create/update header for /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/CompositeX509KeyManager.scala[0m
[0m[[0mdebug[0m] [0mFirst line of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/CompositeX509KeyManager.scala is:[0m
[0m[[0mdebug[0m] [0mText of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/CompositeX509KeyManager.scala is:[0m
[0m[[0mdebug[0m] [0m/*[0m
[0m[[0mdebug[0m] [0m * Copyright (C) 2015 Typesafe Inc. <http://www.typesafe.com>[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mpackage com.typesafe.sslconfig.ssl[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport javax.net.ssl.{ SSLEngine, X509ExtendedKeyManager, X509KeyManager }[0m
[0m[[0mdebug[0m] [0mimport java.security.{ Principal, PrivateKey }[0m
[0m[[0mdebug[0m] [0mimport java.security.cert.{ CertificateException, X509Certificate }[0m
[0m[[0mdebug[0m] [0mimport java.net.Socket[0m
[0m[[0mdebug[0m] [0mimport com.typesafe.sslconfig.util.{ LoggerFactory, NoDepsLogger }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport scala.collection.mutable.ArrayBuffer[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * A keymanager that wraps other X509 key managers.[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0mclass CompositeX509KeyManager(mkLogger: LoggerFactory, keyManagers: Seq[X509KeyManager]) extends X509ExtendedKeyManager {[0m
[0m[[0mdebug[0m] [0m  // Must specify X509ExtendedKeyManager: otherwise you get[0m
[0m[[0mdebug[0m] [0m  // "X509KeyManager passed to SSLContext.init():  need an X509ExtendedKeyManager for SSLEngine use"[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  private val logger = mkLogger(getClass)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  logger.debug(s"CompositeX509KeyManager start: keyManagers = $keyManagers")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  // You would think that from the method signature that you could use multiple key managers and trust managers[0m
[0m[[0mdebug[0m] [0m  // by passing them as an array in the init method.  However, the fine print explicitly says:[0m
[0m[[0mdebug[0m] [0m  // "Only the first instance of a particular key and/or trust manager implementation type in the array is used.[0m
[0m[[0mdebug[0m] [0m  // (For example, only the first javax.net.ssl.X509KeyManager in the array will be used.)"[0m
[0m[[0mdebug[0m] [0m  //[0m
[0m[[0mdebug[0m] [0m  // This doesn't mean you can't have multiple key managers, but that you can't have multiple key managers of[0m
[0m[[0mdebug[0m] [0m  // the same class, i.e. you can't have two X509KeyManagers in the array.[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def getClientAliases(keyType: String, issuers: Array[Principal]): Array[String] = {[0m
[0m[[0mdebug[0m] [0m    logger.debug(s"getClientAliases: keyType = $keyType, issuers = ${issuers.toSeq}")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val clientAliases = new ArrayBuffer[String][0m
[0m[[0mdebug[0m] [0m    withKeyManagers { keyManager =>[0m
[0m[[0mdebug[0m] [0m      val aliases = keyManager.getClientAliases(keyType, issuers)[0m
[0m[[0mdebug[0m] [0m      if (aliases != null) {[0m
[0m[[0mdebug[0m] [0m        clientAliases.appendAll(aliases)[0m
[0m[[0mdebug[0m] [0m      }[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m    logger.debug(s"getCertificateChain: clientAliases = $clientAliases")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    nullIfEmpty(clientAliases.toArray)[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def chooseClientAlias(keyType: Array[String], issuers: Array[Principal], socket: Socket): String = {[0m
[0m[[0mdebug[0m] [0m    logger.debug(s"chooseClientAlias: keyType = ${keyType.toSeq}, issuers = ${issuers.toSeq}, socket = $socket")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    withKeyManagers { keyManager =>[0m
[0m[[0mdebug[0m] [0m      val clientAlias = keyManager.chooseClientAlias(keyType, issuers, socket)[0m
[0m[[0mdebug[0m] [0m      if (clientAlias != null) {[0m
[0m[[0mdebug[0m] [0m        logger.debug(s"chooseClientAlias: using clientAlias $clientAlias with keyManager $keyManager")[0m
[0m[[0mdebug[0m] [0m        return clientAlias[0m
[0m[[0mdebug[0m] [0m      }[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m    null[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  override def chooseEngineClientAlias(keyType: Array[String], issuers: Array[Principal], engine: SSLEngine): String = {[0m
[0m[[0mdebug[0m] [0m    logger.debug(s"chooseEngineClientAlias: keyType = ${keyType.toSeq}, issuers = ${issuers.toSeq}, engine = $engine")[0m
[0m[[0mdebug[0m] [0m    withKeyManagers { keyManager: X509KeyManager =>[0m
[0m[[0mdebug[0m] [0m      keyManager match {[0m
[0m[[0mdebug[0m] [0m        case extendedKeyManager: X509ExtendedKeyManager =>[0m
[0m[[0mdebug[0m] [0m          val clientAlias = extendedKeyManager.chooseEngineClientAlias(keyType, issuers, engine)[0m
[0m[[0mdebug[0m] [0m          if (clientAlias != null) {[0m
[0m[[0mdebug[0m] [0m            logger.debug(s"chooseEngineClientAlias: using clientAlias $clientAlias with keyManager $extendedKeyManager")[0m
[0m[[0mdebug[0m] [0m            return clientAlias[0m
[0m[[0mdebug[0m] [0m          }[0m
[0m[[0mdebug[0m] [0m        case _ =>[0m
[0m[[0mdebug[0m] [0m        // do nothing[0m
[0m[[0mdebug[0m] [0m      }[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m    null[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  override def chooseEngineServerAlias(keyType: String, issuers: Array[Principal], engine: SSLEngine): String = {[0m
[0m[[0mdebug[0m] [0m    logger.debug(s"chooseEngineServerAlias: keyType = ${keyType.toSeq}, issuers = ${issuers.toSeq}, engine = $engine")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    withKeyManagers { keyManager: X509KeyManager =>[0m
[0m[[0mdebug[0m] [0m      keyManager match {[0m
[0m[[0mdebug[0m] [0m        case extendedKeyManager: X509ExtendedKeyManager =>[0m
[0m[[0mdebug[0m] [0m          val clientAlias = extendedKeyManager.chooseEngineServerAlias(keyType, issuers, engine)[0m
[0m[[0mdebug[0m] [0m          if (clientAlias != null) {[0m
[0m[[0mdebug[0m] [0m            logger.debug(s"chooseEngineServerAlias: using clientAlias $clientAlias with keyManager $extendedKeyManager")[0m
[0m[[0mdebug[0m] [0m            return clientAlias[0m
[0m[[0mdebug[0m] [0m          }[0m
[0m[[0mdebug[0m] [0m        case _ =>[0m
[0m[[0mdebug[0m] [0m        // do nothing[0m
[0m[[0mdebug[0m] [0m      }[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m    null[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def getServerAliases(keyType: String, issuers: Array[Principal]): Array[String] = {[0m
[0m[[0mdebug[0m] [0m    logger.debug(s"getServerAliases: keyType = $keyType, issuers = ${issuers.toSeq}")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val serverAliases = new ArrayBuffer[String][0m
[0m[[0mdebug[0m] [0m    withKeyManagers { keyManager =>[0m
[0m[[0mdebug[0m] [0m      val aliases = keyManager.getServerAliases(keyType, issuers)[0m
[0m[[0mdebug[0m] [0m      if (aliases != null) {[0m
[0m[[0mdebug[0m] [0m        serverAliases.appendAll(aliases)[0m
[0m[[0mdebug[0m] [0m      }[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m    logger.debug(s"getServerAliases: serverAliases = $serverAliases")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    nullIfEmpty(serverAliases.toArray)[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def chooseServerAlias(keyType: String, issuers: Array[Principal], socket: Socket): String = {[0m
[0m[[0mdebug[0m] [0m    logger.debug(s"chooseServerAlias: keyType = $keyType, issuers = ${issuers.toSeq}, socket = $socket")[0m
[0m[[0mdebug[0m] [0m    withKeyManagers { keyManager =>[0m
[0m[[0mdebug[0m] [0m      val serverAlias = keyManager.chooseServerAlias(keyType, issuers, socket)[0m
[0m[[0mdebug[0m] [0m      if (serverAlias != null) {[0m
[0m[[0mdebug[0m] [0m        logger.debug(s"chooseServerAlias: using serverAlias $serverAlias with keyManager $keyManager")[0m
[0m[[0mdebug[0m] [0m        return serverAlias[0m
[0m[[0mdebug[0m] [0m      }[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m    null[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def getCertificateChain(alias: String): Array[X509Certificate] = {[0m
[0m[[0mdebug[0m] [0m    logger.debug(s"getCertificateChain: alias = $alias")[0m
[0m[[0mdebug[0m] [0m    withKeyManagers { keyManager =>[0m
[0m[[0mdebug[0m] [0m      val chain = keyManager.getCertificateChain(alias)[0m
[0m[[0mdebug[0m] [0m      if (chain != null && chain.length > 0) {[0m
[0m[[0mdebug[0m] [0m        logger.debug(s"getCertificateChain: chain ${debugChain(chain)} with keyManager $keyManager")[0m
[0m[[0mdebug[0m] [0m        return chain[0m
[0m[[0mdebug[0m] [0m      }[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m    null[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def getPrivateKey(alias: String): PrivateKey = {[0m
[0m[[0mdebug[0m] [0m    logger.debug(s"getPrivateKey: alias = $alias")[0m
[0m[[0mdebug[0m] [0m    withKeyManagers { keyManager =>[0m
[0m[[0mdebug[0m] [0m      val privateKey = keyManager.getPrivateKey(alias)[0m
[0m[[0mdebug[0m] [0m      if (privateKey != null) {[0m
[0m[[0mdebug[0m] [0m        logger.debug(s"getPrivateKey: privateKey $privateKey with keyManager $keyManager")[0m
[0m[[0mdebug[0m] [0m        return privateKey[0m
[0m[[0mdebug[0m] [0m      }[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m    null[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  private def withKeyManagers[T](block: (X509KeyManager => T)): Seq[CertificateException] = {[0m
[0m[[0mdebug[0m] [0m    val exceptionList = ArrayBuffer[CertificateException]()[0m
[0m[[0mdebug[0m] [0m    keyManagers.foreach { keyManager =>[0m
[0m[[0mdebug[0m] [0m      try {[0m
[0m[[0mdebug[0m] [0m        block(keyManager)[0m
[0m[[0mdebug[0m] [0m      } catch {[0m
[0m[[0mdebug[0m] [0m        case certEx: CertificateException =>[0m
[0m[[0mdebug[0m] [0m          exceptionList.append(certEx)[0m
[0m[[0mdebug[0m] [0m      }[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m    exceptionList[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  private def nullIfEmpty[T](array: Array[T]) = if (array.size == 0) null else array[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  override def toString = {[0m
[0m[[0mdebug[0m] [0m    s"CompositeX509KeyManager(keyManagers = [$keyManagers])"[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mModified text of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/CompositeX509KeyManager.scala is:[0m
[0m[[0mdebug[0m] [0mNone[0m
[0m[[0mdebug[0m] [0mAbout to create/update header for /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/CompositeX509TrustManager.scala[0m
[0m[[0mdebug[0m] [0mFirst line of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/CompositeX509TrustManager.scala is:[0m
[0m[[0mdebug[0m] [0mText of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/CompositeX509TrustManager.scala is:[0m
[0m[[0mdebug[0m] [0m/*[0m
[0m[[0mdebug[0m] [0m * Copyright (C) 2015 Typesafe Inc. <http://www.typesafe.com>[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mpackage com.typesafe.sslconfig.ssl[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport javax.net.ssl.X509TrustManager[0m
[0m[[0mdebug[0m] [0mimport java.security.cert._[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport com.typesafe.sslconfig.util.{ LoggerFactory, NoDepsLogger }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport scala.collection.mutable.ArrayBuffer[0m
[0m[[0mdebug[0m] [0mimport scala.util.control.NonFatal[0m
[0m[[0mdebug[0m] [0mimport java.security.GeneralSecurityException[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * A trust manager that is a composite of several smaller trust managers.   It is responsible for verifying the[0m
[0m[[0mdebug[0m] [0m * credentials received from a peer.[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0mclass CompositeX509TrustManager(mkLogger: LoggerFactory, trustManagers: Seq[X509TrustManager], algorithmChecker: AlgorithmChecker) extends X509TrustManager {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  private val logger = mkLogger(getClass)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def getAcceptedIssuers: Array[X509Certificate] = {[0m
[0m[[0mdebug[0m] [0m    logger.debug("getAcceptedIssuers: ")[0m
[0m[[0mdebug[0m] [0m    val certificates = ArrayBuffer[X509Certificate]()[0m
[0m[[0mdebug[0m] [0m    val exceptionList = withTrustManagers {[0m
[0m[[0mdebug[0m] [0m      trustManager =>[0m
[0m[[0mdebug[0m] [0m        certificates.appendAll(trustManager.getAcceptedIssuers)[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m    // getAcceptedIssuers should never throw an exception.[0m
[0m[[0mdebug[0m] [0m    if (!exceptionList.isEmpty) {[0m
[0m[[0mdebug[0m] [0m      val msg = exceptionList(0).getMessage[0m
[0m[[0mdebug[0m] [0m      throw new CompositeCertificateException(msg, exceptionList.toArray)[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m    certificates.toArray[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  // In 1.6, sun.security.ssl.X509TrustManagerImpl extends from com.sun.net.ssl.internal.ssl.X509ExtendedTrustManager[0m
[0m[[0mdebug[0m] [0m  // In 1.7, sun.security.ssl.X509TrustManagerImpl extends from javax.net.ssl.X509ExtendedTrustManager.[0m
[0m[[0mdebug[0m] [0m  // The two X509ExtendedTrustManager contain different method signatures, and both are available in 1.7, which means[0m
[0m[[0mdebug[0m] [0m  // it's really hard to keep something backwards compatible if something is calling trustManager.asInstanceOf[X509ExtendedTrustManager][0m
[0m[[0mdebug[0m] [0m  // internally.  For now, we have to trust that the internal API holds to the X509TrustManager interface.[0m
[0m[[0mdebug[0m] [0m  //[0m
[0m[[0mdebug[0m] [0m  //def checkClientTrusted(chain: Array[X509Certificate], authType: String, hostname: String, algorithm: String): Unit = ???[0m
[0m[[0mdebug[0m] [0m  //def checkServerTrusted(chain: Array[X509Certificate], authType: String, hostname: String, algorithm: String): Unit = ???[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def checkClientTrusted(chain: Array[X509Certificate], authType: String) {[0m
[0m[[0mdebug[0m] [0m    logger.debug(s"checkClientTrusted: chain = ${debugChain(chain)}")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val anchor: TrustAnchor = new TrustAnchor(chain(chain.length - 1), null)[0m
[0m[[0mdebug[0m] [0m    logger.debug(s"checkClientTrusted: checking key size only on root anchor $anchor")[0m
[0m[[0mdebug[0m] [0m    algorithmChecker.checkKeyAlgorithms(anchor.getTrustedCert)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    var trusted = false[0m
[0m[[0mdebug[0m] [0m    val exceptionList = withTrustManagers {[0m
[0m[[0mdebug[0m] [0m      trustManager =>[0m
[0m[[0mdebug[0m] [0m        trustManager.checkClientTrusted(chain, authType)[0m
[0m[[0mdebug[0m] [0m        logger.debug(s"checkClientTrusted: trustManager $trustManager found a match for ${debugChain(chain)}")[0m
[0m[[0mdebug[0m] [0m        trusted = true[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    if (!trusted) {[0m
[0m[[0mdebug[0m] [0m      val msg = "No trust manager was able to validate this certificate chain."[0m
[0m[[0mdebug[0m] [0m      throw new CompositeCertificateException(msg, exceptionList.toArray)[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def checkServerTrusted(chain: Array[X509Certificate], authType: String): Unit = {[0m
[0m[[0mdebug[0m] [0m    logger.debug(s"checkServerTrusted: chain = ${debugChain(chain)}, authType = $authType")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    // Trust anchor is at the end of the chain... there is no way to pass a trust anchor[0m
[0m[[0mdebug[0m] [0m    // through to a checker in PKIXCertPathValidator.doValidate(), so the trust manager is the[0m
[0m[[0mdebug[0m] [0m    // last place we have access to it.[0m
[0m[[0mdebug[0m] [0m    val anchor: TrustAnchor = new TrustAnchor(chain(chain.length - 1), null)[0m
[0m[[0mdebug[0m] [0m    logger.debug(s"checkServerTrusted: checking key size only on root anchor $anchor")[0m
[0m[[0mdebug[0m] [0m    algorithmChecker.checkKeyAlgorithms(anchor.getTrustedCert)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    var trusted = false[0m
[0m[[0mdebug[0m] [0m    val exceptionList = withTrustManagers {[0m
[0m[[0mdebug[0m] [0m      trustManager =>[0m
[0m[[0mdebug[0m] [0m        // always run through the trust manager before making any decisions[0m
[0m[[0mdebug[0m] [0m        trustManager.checkServerTrusted(chain, authType)[0m
[0m[[0mdebug[0m] [0m        logger.debug(s"checkServerTrusted: trustManager $trustManager using authType $authType found a match for ${debugChain(chain).toSeq}")[0m
[0m[[0mdebug[0m] [0m        trusted = true[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    if (!trusted) {[0m
[0m[[0mdebug[0m] [0m      val msg = s"No trust manager was able to validate this certificate chain: # of exceptions = ${exceptionList.size}"[0m
[0m[[0mdebug[0m] [0m      throw new CompositeCertificateException(msg, exceptionList.toArray)[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  private def withTrustManagers(block: (X509TrustManager => Unit)): Seq[Throwable] = {[0m
[0m[[0mdebug[0m] [0m    val exceptionList = ArrayBuffer[Throwable]()[0m
[0m[[0mdebug[0m] [0m    trustManagers.foreach {[0m
[0m[[0mdebug[0m] [0m      trustManager =>[0m
[0m[[0mdebug[0m] [0m        try {[0m
[0m[[0mdebug[0m] [0m          block(trustManager)[0m
[0m[[0mdebug[0m] [0m        } catch {[0m
[0m[[0mdebug[0m] [0m          case e: CertPathBuilderException =>[0m
[0m[[0mdebug[0m] [0m            logger.debug(s"No path found to certificate: this usually means the CA is not in the trust store. Cause: $e")[0m
[0m[[0mdebug[0m] [0m            exceptionList.append(e)[0m
[0m[[0mdebug[0m] [0m          case e: GeneralSecurityException =>[0m
[0m[[0mdebug[0m] [0m            logger.debug(s"General security exception. Cause: $e")[0m
[0m[[0mdebug[0m] [0m            exceptionList.append(e)[0m
[0m[[0mdebug[0m] [0m          case NonFatal(e) =>[0m
[0m[[0mdebug[0m] [0m            logger.debug(s"Unexpected exception! Cause: $e")[0m
[0m[[0mdebug[0m] [0m            exceptionList.append(e)[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m    exceptionList[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  override def toString = {[0m
[0m[[0mdebug[0m] [0m    s"CompositeX509TrustManager(trustManagers = [$trustManagers], algorithmChecker = $algorithmChecker)"[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mModified text of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/CompositeX509TrustManager.scala is:[0m
[0m[[0mdebug[0m] [0mNone[0m
[0m[[0mdebug[0m] [0mAbout to create/update header for /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/Debug.scala[0m
[0m[[0mdebug[0m] [0mFirst line of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/Debug.scala is:[0m
[0m[[0mdebug[0m] [0mText of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/Debug.scala is:[0m
[0m[[0mdebug[0m] [0m/*[0m
[0m[[0mdebug[0m] [0m * Copyright (C) 2015 Typesafe Inc. <http://www.typesafe.com>[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mpackage com.typesafe.sslconfig.ssl[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * @see http://docs.oracle.com/javase/8/docs/technotes/guides/security/certpath/CertPathProgGuide.html[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0mclass JavaSecurityDebugBuilder(c: SSLDebugConfig) {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def build(): String = {[0m
[0m[[0mdebug[0m] [0m    val b = new StringBuilder()[0m
[0m[[0mdebug[0m] [0m    if (c.certpath) {[0m
[0m[[0mdebug[0m] [0m      b.append(" certpath")[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    if (c.ocsp) {[0m
[0m[[0mdebug[0m] [0m      // http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7u40-b43/sun/security/provider/certpath/OCSPResponse.java#132[0m
[0m[[0mdebug[0m] [0m      b.append(" ocsp")[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    b.toString()[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * A builder for setting the system property options in "javax.net.debug" and in "java.security.debug' (in[0m
[0m[[0mdebug[0m] [0m * the case of "certpath").[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * @see http://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/JSSERefGuide.html#Debug[0m
[0m[[0mdebug[0m] [0m * @see http://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/ReadDebug.html[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0mclass JavaxNetDebugBuilder(c: SSLDebugConfig) {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def build(): String = {[0m
[0m[[0mdebug[0m] [0m    if (c.all) return "all"[0m
[0m[[0mdebug[0m] [0m    buildSSL(c)[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  protected def buildSSL(sslDebugConfig: SSLDebugConfig): String = {[0m
[0m[[0mdebug[0m] [0m    import sslDebugConfig._[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val b = new StringBuilder()[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    record.map {[0m
[0m[[0mdebug[0m] [0m      r =>[0m
[0m[[0mdebug[0m] [0m        b.append(" record")[0m
[0m[[0mdebug[0m] [0m        if (r.packet) {[0m
[0m[[0mdebug[0m] [0m          b.append(" packet")[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m        if (r.plaintext) {[0m
[0m[[0mdebug[0m] [0m          b.append(" plaintext")[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    handshake.map {[0m
[0m[[0mdebug[0m] [0m      h =>[0m
[0m[[0mdebug[0m] [0m        b.append(" handshake")[0m
[0m[[0mdebug[0m] [0m        if (h.data) {[0m
[0m[[0mdebug[0m] [0m          b.append(" data")[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m        if (h.verbose) {[0m
[0m[[0mdebug[0m] [0m          b.append(" verbose")[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    if (keygen) {[0m
[0m[[0mdebug[0m] [0m      b.append(" keygen")[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    if (session) {[0m
[0m[[0mdebug[0m] [0m      b.append(" session")[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    if (defaultctx) {[0m
[0m[[0mdebug[0m] [0m      b.append(" defaultctx")[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    if (sslctx) {[0m
[0m[[0mdebug[0m] [0m      b.append(" sslctx")[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    if (sessioncache) {[0m
[0m[[0mdebug[0m] [0m      b.append(" sessioncache")[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    if (keymanager) {[0m
[0m[[0mdebug[0m] [0m      b.append(" keymanager")[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    if (trustmanager) {[0m
[0m[[0mdebug[0m] [0m      b.append(" trustmanager")[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    if (pluggability) {[0m
[0m[[0mdebug[0m] [0m      b.append(" pluggability")[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    if ((!b.isEmpty) || ssl) {[0m
[0m[[0mdebug[0m] [0m      b.append(" ssl")[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    b.toString()[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mModified text of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/Debug.scala is:[0m
[0m[[0mdebug[0m] [0mNone[0m
[0m[[0mdebug[0m] [0mAbout to create/update header for /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/DisabledComplainingHostnameVerifier.scala[0m
[0m[[0mdebug[0m] [0mFirst line of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/DisabledComplainingHostnameVerifier.scala is:[0m
[0m[[0mdebug[0m] [0mText of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/DisabledComplainingHostnameVerifier.scala is:[0m
[0m[[0mdebug[0m] [0m/*[0m
[0m[[0mdebug[0m] [0m * Copyright (C) 2015 Typesafe Inc. <http://www.typesafe.com>[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mpackage com.typesafe.sslconfig.ssl[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport javax.net.ssl.{ SSLSession, HostnameVerifier }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport com.typesafe.sslconfig.util.{ LoggerFactory, NoDepsLogger }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * Add a disabled but complaining hostname verifier.[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0mclass DisabledComplainingHostnameVerifier(mkLogger: LoggerFactory) extends HostnameVerifier {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  private val logger = mkLogger(getClass)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  private val defaultHostnameVerifier = new DefaultHostnameVerifier(mkLogger)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  override def verify(hostname: String, sslSession: SSLSession): Boolean = {[0m
[0m[[0mdebug[0m] [0m    val hostNameMatches = defaultHostnameVerifier.verify(hostname, sslSession)[0m
[0m[[0mdebug[0m] [0m    if (!hostNameMatches) {[0m
[0m[[0mdebug[0m] [0m      // TODO fix config paths[0m
[0m[[0mdebug[0m] [0m      val msg =[0m
[0m[[0mdebug[0m] [0m        s"Hostname verification failed on hostname $hostname, " +[0m
[0m[[0mdebug[0m] [0m          "but the connection was accepted because ssl-config.loose.disableHostnameVerification is enabled. " +[0m
[0m[[0mdebug[0m] [0m          "Please fix the X.509 certificate on the host to remove this warning."[0m
[0m[[0mdebug[0m] [0m      logger.warn(msg)[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m    true[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mModified text of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/DisabledComplainingHostnameVerifier.scala is:[0m
[0m[[0mdebug[0m] [0mNone[0m
[0m[[0mdebug[0m] [0mAbout to create/update header for /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/Ciphers.scala[0m
[0m[[0mdebug[0m] [0mFirst line of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/Ciphers.scala is:[0m
[0m[[0mdebug[0m] [0mText of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/Ciphers.scala is:[0m
[0m[[0mdebug[0m] [0m/*[0m
[0m[[0mdebug[0m] [0m * Copyright (C) 2015 Typesafe Inc. <http://www.typesafe.com>[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mpackage com.typesafe.sslconfig.ssl[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport javax.net.ssl.SSLContext[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * This class contains sets of recommended and deprecated TLS cipher suites.[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * The JSSE list of cipher suites is different from the RFC defined list, with some cipher suites prefixed with "SSL_"[0m
[0m[[0mdebug[0m] [0m * instead of "TLS_".  A full list is available from the <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/SunProviders.html#SupportedCipherSuites">SunJSSE provider list</a>[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * Please see https://www.playframework.com/documentation/current/CipherSuites for more details.[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0mobject Ciphers {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  // We want to prioritize ECC and perfect forward security.[0m
[0m[[0mdebug[0m] [0m  // Unfortunately, ECC is only available under the "SunEC" provider, which is part of Oracle JDK.  If you're[0m
[0m[[0mdebug[0m] [0m  // using OpenJDK, you're out of luck.[0m
[0m[[0mdebug[0m] [0m  // http://armoredbarista.blogspot.com/2013/10/how-to-use-ecc-with-openjdk.html[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def recommendedCiphers: Seq[String] = foldVersion([0m
[0m[[0mdebug[0m] [0m    run16 = java16RecommendedCiphers,[0m
[0m[[0mdebug[0m] [0m    runHigher = java17RecommendedCiphers)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  lazy val java17RecommendedCiphers: Seq[String] = {[0m
[0m[[0mdebug[0m] [0m    SSLContext.getDefault.getDefaultSSLParameters.getCipherSuites[0m
[0m[[0mdebug[0m] [0m  }.filterNot(deprecatedCiphers.contains(_))[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  val java16RecommendedCiphers: Seq[String] = Seq([0m
[0m[[0mdebug[0m] [0m    "TLS_DHE_RSA_WITH_AES_128_CBC_SHA",[0m
[0m[[0mdebug[0m] [0m    "TLS_DHE_RSA_WITH_AES_256_CBC_SHA",[0m
[0m[[0mdebug[0m] [0m    "TLS_DHE_DSS_WITH_AES_128_CBC_SHA",[0m
[0m[[0mdebug[0m] [0m    "TLS_RSA_WITH_AES_256_CBC_SHA",[0m
[0m[[0mdebug[0m] [0m    "TLS_RSA_WITH_AES_128_CBC_SHA",[0m
[0m[[0mdebug[0m] [0m    "SSL_RSA_WITH_3DES_EDE_CBC_SHA",[0m
[0m[[0mdebug[0m] [0m    "TLS_EMPTY_RENEGOTIATION_INFO_SCSV" // per RFC 5746[0m
[0m[[0mdebug[0m] [0m  )[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  // Suite B profile for TLS (requires 1.2): http://tools.ietf.org/html/rfc6460[0m
[0m[[0mdebug[0m] [0m  // http://adambard.com/blog/the-new-ssl-basics/[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  // Even 1.7 doesn't support TLS_ECDHE_ECDSA_WITH_AES_256.[0m
[0m[[0mdebug[0m] [0m  // TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 is the best you get,[0m
[0m[[0mdebug[0m] [0m  // and it's also at the top of the default 1.7 cipher list.[0m
[0m[[0mdebug[0m] [0m  val suiteBCiphers: Seq[String] = """[0m
[0m[[0mdebug[0m] [0m                                     |TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384[0m
[0m[[0mdebug[0m] [0m                                     |TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384[0m
[0m[[0mdebug[0m] [0m                                     |TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256[0m
[0m[[0mdebug[0m] [0m                                     |TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256[0m
[0m[[0mdebug[0m] [0m                                   """.stripMargin.split("\n")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  val suiteBTransitionalCiphers: Seq[String] = """TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384[0m
[0m[[0mdebug[0m] [0m                                                 |TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384[0m
[0m[[0mdebug[0m] [0m                                                 |TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256[0m
[0m[[0mdebug[0m] [0m                                                 |TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256[0m
[0m[[0mdebug[0m] [0m                                                 |TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA[0m
[0m[[0mdebug[0m] [0m                                                 |TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA[0m
[0m[[0mdebug[0m] [0m                                               """.stripMargin.split("\n")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  // From http://op-co.de/blog/posts/android_ssl_downgrade/[0m
[0m[[0mdebug[0m] [0m  // Caveat: https://news.ycombinator.com/item?id=6548545[0m
[0m[[0mdebug[0m] [0m  val recommendedSmithCiphers = Seq([0m
[0m[[0mdebug[0m] [0m    "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA",[0m
[0m[[0mdebug[0m] [0m    "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA",[0m
[0m[[0mdebug[0m] [0m    "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA",[0m
[0m[[0mdebug[0m] [0m    "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA",[0m
[0m[[0mdebug[0m] [0m    "TLS_DHE_RSA_WITH_AES_128_CBC_SHA",[0m
[0m[[0mdebug[0m] [0m    "TLS_DHE_RSA_WITH_AES_256_CBC_SHA",[0m
[0m[[0mdebug[0m] [0m    "TLS_DHE_DSS_WITH_AES_128_CBC_SHA",[0m
[0m[[0mdebug[0m] [0m    "TLS_RSA_WITH_AES_128_CBC_SHA",[0m
[0m[[0mdebug[0m] [0m    "TLS_RSA_WITH_AES_256_CBC_SHA",[0m
[0m[[0mdebug[0m] [0m    "SSL_RSA_WITH_3DES_EDE_CBC_SHA"[0m
[0m[[0mdebug[0m] [0m  )[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  val exportCiphers = """SSL_RSA_EXPORT_WITH_RC4_40_MD5[0m
[0m[[0mdebug[0m] [0m                        |SSL_RSA_EXPORT_WITH_DES40_CBC_SHA[0m
[0m[[0mdebug[0m] [0m                        |SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA[0m
[0m[[0mdebug[0m] [0m                        |SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA[0m
[0m[[0mdebug[0m] [0m                        |TLS_KRB5_EXPORT_WITH_RC4_40_SHA[0m
[0m[[0mdebug[0m] [0m                        |TLS_KRB5_EXPORT_WITH_RC4_40_MD5[0m
[0m[[0mdebug[0m] [0m                        |TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA[0m
[0m[[0mdebug[0m] [0m                        |TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5[0m
[0m[[0mdebug[0m] [0m                      """.stripMargin.split("\n").toSet[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  // Per RFC2246 section 11.5 (A.5)[0m
[0m[[0mdebug[0m] [0m  val anonCiphers = """TLS_DH_anon_WITH_RC4_128_MD5[0m
[0m[[0mdebug[0m] [0m                      |TLS_DH_anon_WITH_AES_128_CBC_SHA[0m
[0m[[0mdebug[0m] [0m                      |TLS_DH_anon_EXPORT_WITH_RC4_40_MD5[0m
[0m[[0mdebug[0m] [0m                      |TLS_DH_anon_WITH_RC4_128_MD5[0m
[0m[[0mdebug[0m] [0m                      |TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA[0m
[0m[[0mdebug[0m] [0m                      |TLS_DH_anon_WITH_DES_CBC_SHA[0m
[0m[[0mdebug[0m] [0m                      |TLS_DH_anon_WITH_3DES_EDE_CBC_SHA[0m
[0m[[0mdebug[0m] [0m                      |TLS_DH_anon_WITH_AES_128_CBC_SHA[0m
[0m[[0mdebug[0m] [0m                      |TLS_DH_anon_WITH_AES_256_CBC_SHA[0m
[0m[[0mdebug[0m] [0m                      |TLS_ECDH_anon_WITH_RC4_128_SHA[0m
[0m[[0mdebug[0m] [0m                      |TLS_ECDH_anon_WITH_AES_128_CBC_SHA[0m
[0m[[0mdebug[0m] [0m                      |TLS_ECDH_anon_WITH_AES_256_CBC_SHA[0m
[0m[[0mdebug[0m] [0m                      |TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA[0m
[0m[[0mdebug[0m] [0m                      |TLS_ECDH_anon_WITH_NULL_SHA[0m
[0m[[0mdebug[0m] [0m                      |SSL_DH_anon_WITH_RC4_128_MD5[0m
[0m[[0mdebug[0m] [0m                      |SSL_DH_anon_WITH_3DES_EDE_CBC_SHA[0m
[0m[[0mdebug[0m] [0m                      |SSL_DH_anon_WITH_DES_CBC_SHA[0m
[0m[[0mdebug[0m] [0m                      |SSL_DH_anon_EXPORT_WITH_RC4_40_MD5[0m
[0m[[0mdebug[0m] [0m                      |SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA[0m
[0m[[0mdebug[0m] [0m                    """.stripMargin.split("\n").toSet[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  val nullCiphers = """SSL_RSA_WITH_NULL_MD5[0m
[0m[[0mdebug[0m] [0m                      |SSL_RSA_WITH_NULL_SHA[0m
[0m[[0mdebug[0m] [0m                      |TLS_ECDH_ECDSA_WITH_NULL_SHA[0m
[0m[[0mdebug[0m] [0m                      |TLS_ECDH_RSA_WITH_NULL_SHA[0m
[0m[[0mdebug[0m] [0m                      |TLS_ECDHE_ECDSA_WITH_NULL_SHA[0m
[0m[[0mdebug[0m] [0m                      |TLS_ECDHE_RSA_WITH_NULL_SHA[0m
[0m[[0mdebug[0m] [0m                    """.stripMargin.split("\n").toSet[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  val desCiphers = """SSL_RSA_WITH_DES_CBC_SHA[0m
[0m[[0mdebug[0m] [0m                     |SSL_DHE_RSA_WITH_DES_CBC_SHA[0m
[0m[[0mdebug[0m] [0m                     |SSL_DHE_DSS_WITH_DES_CBC_SHA[0m
[0m[[0mdebug[0m] [0m                     |TLS_KRB5_WITH_DES_CBC_SHA[0m
[0m[[0mdebug[0m] [0m                   """.stripMargin.split("\n").toSet[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  val md5Ciphers = """SSL_RSA_WITH_RC4_128_MD5[0m
[0m[[0mdebug[0m] [0m                     |SSL_RSA_WITH_NULL_MD5[0m
[0m[[0mdebug[0m] [0m                     |SSL_RSA_EXPORT_WITH_RC4_40_MD5[0m
[0m[[0mdebug[0m] [0m                     |SSL_DH_anon_EXPORT_WITH_RC4_40_MD5[0m
[0m[[0mdebug[0m] [0m                     |SSL_DH_anon_WITH_RC4_128_MD5[0m
[0m[[0mdebug[0m] [0m                     |TLS_KRB5_WITH_DES_CBC_MD5[0m
[0m[[0mdebug[0m] [0m                     |TLS_KRB5_WITH_3DES_EDE_CBC_MD5[0m
[0m[[0mdebug[0m] [0m                     |TLS_KRB5_WITH_RC4_128_MD5[0m
[0m[[0mdebug[0m] [0m                     |TLS_KRB5_WITH_IDEA_CBC_MD5[0m
[0m[[0mdebug[0m] [0m                     |TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5[0m
[0m[[0mdebug[0m] [0m                     |TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5[0m
[0m[[0mdebug[0m] [0m                     |TLS_KRB5_EXPORT_WITH_RC4_40_MD5[0m
[0m[[0mdebug[0m] [0m                   """.stripMargin.split("\n").toSet[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  val rc4Ciphers = """SSL_DH_anon_EXPORT_WITH_RC4_40_MD5[0m
[0m[[0mdebug[0m] [0m                     |SSL_DH_anon_WITH_RC4_128_MD5[0m
[0m[[0mdebug[0m] [0m                     |SSL_RSA_EXPORT_WITH_RC4_40_MD5[0m
[0m[[0mdebug[0m] [0m                     |SSL_RSA_WITH_RC4_128_MD5[0m
[0m[[0mdebug[0m] [0m                     |SSL_RSA_WITH_RC4_128_SHA[0m
[0m[[0mdebug[0m] [0m                     |TLS_DHE_PSK_WITH_RC4_128_SHA[0m
[0m[[0mdebug[0m] [0m                     |TLS_ECDHE_ECDSA_WITH_RC4_128_SHA[0m
[0m[[0mdebug[0m] [0m                     |TLS_ECDHE_PSK_WITH_RC4_128_SHA[0m
[0m[[0mdebug[0m] [0m                     |TLS_ECDHE_RSA_WITH_RC4_128_SHA[0m
[0m[[0mdebug[0m] [0m                     |TLS_ECDH_anon_WITH_RC4_128_SHA[0m
[0m[[0mdebug[0m] [0m                     |TLS_ECDH_ECDSA_WITH_RC4_128_SHA[0m
[0m[[0mdebug[0m] [0m                     |TLS_ECDH_RSA_WITH_RC4_128_SHA[0m
[0m[[0mdebug[0m] [0m                     |TLS_KRB5_EXPORT_WITH_RC4_40_MD5[0m
[0m[[0mdebug[0m] [0m                     |TLS_KRB5_EXPORT_WITH_RC4_40_SHA[0m
[0m[[0mdebug[0m] [0m                     |TLS_KRB5_WITH_RC4_128_MD5[0m
[0m[[0mdebug[0m] [0m                     |TLS_KRB5_WITH_RC4_128_SHA[0m
[0m[[0mdebug[0m] [0m                     |TLS_PSK_WITH_RC4_128_SHA[0m
[0m[[0mdebug[0m] [0m                     |TLS_RSA_PSK_WITH_RC4_128_SHA[0m
[0m[[0mdebug[0m] [0m                   """.stripMargin.split("\n").toSet[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  val sha1Ciphers = """SSL_RSA_WITH_RC4_128_SHA[0m
[0m[[0mdebug[0m] [0m                      |TLS_RSA_EXPORT_WITH_DES40_CBC_SHA[0m
[0m[[0mdebug[0m] [0m                      |TLS_ECDH_ECDSA_WITH_RC4_128_SHA[0m
[0m[[0mdebug[0m] [0m                      |TLS_ECDH_RSA_WITH_RC4_128_SHA[0m
[0m[[0mdebug[0m] [0m                      |TLS_ECDHE_ECDSA_WITH_RC4_128_SHA[0m
[0m[[0mdebug[0m] [0m                      |TLS_ECDHE_RSA_WITH_RC4_128_SHA[0m
[0m[[0mdebug[0m] [0m                      |TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA[0m
[0m[[0mdebug[0m] [0m                      |TLS_DHE_DSS_WITH_DES_CBC_SHA[0m
[0m[[0mdebug[0m] [0m                      |TLS_DHE_DSS_WITH_AES_256_CBC_SHA[0m
[0m[[0mdebug[0m] [0m                      |TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA[0m
[0m[[0mdebug[0m] [0m                      |TLS_DHE_DSS_WITH_AES_128_CBC_SHA[0m
[0m[[0mdebug[0m] [0m                      |TLS_DHE_RSA_WITH_DES_CBC_SHA[0m
[0m[[0mdebug[0m] [0m                      |TLS_DHE_RSA_WITH_AES_128_CBC_SHA[0m
[0m[[0mdebug[0m] [0m                      |TLS_DHE_RSA_WITH_AES_256_CBC_SHA[0m
[0m[[0mdebug[0m] [0m                      |TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA[0m
[0m[[0mdebug[0m] [0m                      |TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA[0m
[0m[[0mdebug[0m] [0m                      |TLS_DH_anon_WITH_AES_256_CBC_SHA[0m
[0m[[0mdebug[0m] [0m                    """.stripMargin.split("\n").toSet[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  // See RFC 4346, RFC 5246, and RFC 5469[0m
[0m[[0mdebug[0m] [0m  // rc4 added to deprecated ciphers as of https://tools.ietf.org/html/rfc7465[0m
[0m[[0mdebug[0m] [0m  val deprecatedCiphers = desCiphers ++ nullCiphers ++ anonCiphers ++ exportCiphers ++ rc4Ciphers[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mModified text of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/Ciphers.scala is:[0m
[0m[[0mdebug[0m] [0mNone[0m
[0m[[0mdebug[0m] [0mAbout to create/update header for /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/debug/ClassFinder.scala[0m
[0m[[0mdebug[0m] [0mFirst line of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/debug/ClassFinder.scala is:[0m
[0m[[0mdebug[0m] [0mText of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/debug/ClassFinder.scala is:[0m
[0m[[0mdebug[0m] [0m/*[0m
[0m[[0mdebug[0m] [0m * Copyright (C) 2015 Typesafe Inc. <http://www.typesafe.com>[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mpackage com.typesafe.sslconfig.ssl.debug[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport java.net.{ URLConnection, URL }[0m
[0m[[0mdebug[0m] [0mimport java.util.jar.{ JarEntry, JarInputStream }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport com.typesafe.sslconfig.util.NoDepsLogger[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * Loads a set of classes from a package (including ones which are NOT already in the classloader)[0m
[0m[[0mdebug[0m] [0m * and return the set that[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0mtrait ClassFinder {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def logger: NoDepsLogger[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * A resource (in a jar file, usually) in the format "/java/lang/String.class".  This returns[0m
[0m[[0mdebug[0m] [0m   * an initial URL that leads to the JAR file we search for classes.[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def initialResource: String[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Returns true if this is a "valid" class, i.e. one we want to return in a set.  Note that all[0m
[0m[[0mdebug[0m] [0m   * found classes are loaded into the current thread's classloader, even they are not returned.[0m
[0m[[0mdebug[0m] [0m   *[0m
[0m[[0mdebug[0m] [0m   * @return true if this class should be returned in the set of findClasses, false otherwise.[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def isValidClass(className: String): Boolean[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def findClasses: Set[Class[_]] = {[0m
[0m[[0mdebug[0m] [0m    logger.debug(s"findClasses: using initialResource = $initialResource")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val classSet = scala.collection.mutable.Set[Class[_]]()[0m
[0m[[0mdebug[0m] [0m    val classLoader: ClassLoader = Thread.currentThread.getContextClassLoader[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val urlToSource: URL = this.getClass.getResource(initialResource)[0m
[0m[[0mdebug[0m] [0m    logger.debug(s"findClasses: urlToSource = $urlToSource")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val parts: Array[String] = urlToSource.toString.split("!")[0m
[0m[[0mdebug[0m] [0m    val jarURLString: String = parts(0).replace("jar:", "")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    logger.debug(s"findClasses: Loading from $jarURLString")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val jar: URL = new URL(jarURLString)[0m
[0m[[0mdebug[0m] [0m    val jarConnection: URLConnection = jar.openConnection[0m
[0m[[0mdebug[0m] [0m    val jis: JarInputStream = new JarInputStream(jarConnection.getInputStream)[0m
[0m[[0mdebug[0m] [0m    try {[0m
[0m[[0mdebug[0m] [0m      var je: JarEntry = jis.getNextJarEntry[0m
[0m[[0mdebug[0m] [0m      while (je != null) {[0m
[0m[[0mdebug[0m] [0m        if (!je.isDirectory) {[0m
[0m[[0mdebug[0m] [0m          var className: String = je.getName.substring(0, je.getName.length - 6)[0m
[0m[[0mdebug[0m] [0m          className = className.replace('/', '.')[0m
[0m[[0mdebug[0m] [0m          if (isValidClass(className)) {[0m
[0m[[0mdebug[0m] [0m            //logger.debug(s"findClasses: adding valid class ${className}")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m            val c: Class[_] = classLoader.loadClass(className)[0m
[0m[[0mdebug[0m] [0m            classSet.add(c)[0m
[0m[[0mdebug[0m] [0m          }[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m        je = jis.getNextJarEntry[0m
[0m[[0mdebug[0m] [0m      }[0m
[0m[[0mdebug[0m] [0m    } finally {[0m
[0m[[0mdebug[0m] [0m      jis.close()[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m    classSet.toSet[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mModified text of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/debug/ClassFinder.scala is:[0m
[0m[[0mdebug[0m] [0mNone[0m
[0m[[0mdebug[0m] [0mAbout to create/update header for /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/debug/FixInternalDebugLogging.scala[0m
[0m[[0mdebug[0m] [0mFirst line of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/debug/FixInternalDebugLogging.scala is:[0m
[0m[[0mdebug[0m] [0mText of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/debug/FixInternalDebugLogging.scala is:[0m
[0m[[0mdebug[0m] [0m/*[0m
[0m[[0mdebug[0m] [0m * Copyright (C) 2015 Typesafe Inc. <http://www.typesafe.com>[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mpackage com.typesafe.sslconfig.ssl.debug[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport com.typesafe.sslconfig.ssl._[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport java.security.AccessController[0m
[0m[[0mdebug[0m] [0mimport com.typesafe.sslconfig.util.{ LoggerFactory, NoDepsLogger }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport scala.util.control.NonFatal[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * This fixes logging for the SSL Debug class. It will worth for both Java 1.6 and Java 1.7 VMs.[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0mclass FixInternalDebugLogging(mkLogger: LoggerFactory) {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  private val logger = mkLogger("com.typesafe.sslconfig.ssl.debug.FixInternalDebugLogging")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  class MonkeyPatchInternalSslDebugAction(val newOptions: String) extends FixLoggingAction {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    override val logger = mkLogger("com.typesafe.sslconfig.ssl.debug.FixInternalDebugLogging.MonkeyPatchInternalSslDebugAction")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val initialResource = foldRuntime([0m
[0m[[0mdebug[0m] [0m      older = "/javax/net/ssl/SSLContext.class", // in 1.6 the JSSE classes are in rt.jar[0m
[0m[[0mdebug[0m] [0m      newer = "/sun/security/ssl/Debug.class" // in 1.7 the JSSE classes are in jsse.jar[0m
[0m[[0mdebug[0m] [0m    )[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val debugClassName = foldRuntime([0m
[0m[[0mdebug[0m] [0m      older = "com.sun.net.ssl.internal.ssl.Debug",[0m
[0m[[0mdebug[0m] [0m      newer = "sun.security.ssl.Debug"[0m
[0m[[0mdebug[0m] [0m    )[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    /**[0m
[0m[[0mdebug[0m] [0m     * Returns true if this class has an instance of the class returned by debugClassName, false otherwise.[0m
[0m[[0mdebug[0m] [0m     *[0m
[0m[[0mdebug[0m] [0m     * @param className the name of the class.[0m
[0m[[0mdebug[0m] [0m     * @return true if this class should be returned in the set of findClasses, false otherwise.[0m
[0m[[0mdebug[0m] [0m     */[0m
[0m[[0mdebug[0m] [0m    def isValidClass(className: String): Boolean = {[0m
[0m[[0mdebug[0m] [0m      if (className.startsWith("com.sun.net.ssl.internal.ssl")) return true[0m
[0m[[0mdebug[0m] [0m      if (className.startsWith("sun.security.ssl")) return true[0m
[0m[[0mdebug[0m] [0m      false[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    /**[0m
[0m[[0mdebug[0m] [0m     * Returns true if newOptions is not null and newOptions is not empty.  If false, then debug values[0m
[0m[[0mdebug[0m] [0m     *[0m
[0m[[0mdebug[0m] [0m     * @return[0m
[0m[[0mdebug[0m] [0m     */[0m
[0m[[0mdebug[0m] [0m    def isUsingDebug: Boolean = (newOptions != null) && (!newOptions.isEmpty)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    def run() {[0m
[0m[[0mdebug[0m] [0m      System.setProperty("javax.net.debug", newOptions)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m      val debugType: Class[_] = Thread.currentThread().getContextClassLoader.loadClass(debugClassName)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m      val newDebug: AnyRef = debugType.newInstance().asInstanceOf[AnyRef][0m
[0m[[0mdebug[0m] [0m      logger.debug(s"run: debugType = $debugType")[0m
[0m[[0mdebug[0m] [0m      val debugValue = if (isUsingDebug) newDebug else null[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m      var isPatched = false[0m
[0m[[0mdebug[0m] [0m      for {[0m
[0m[[0mdebug[0m] [0m        debugClass <- findClasses[0m
[0m[[0mdebug[0m] [0m        debugField <- debugClass.getDeclaredFields[0m
[0m[[0mdebug[0m] [0m      } {[0m
[0m[[0mdebug[0m] [0m        if (isValidField(debugField, debugType)) {[0m
[0m[[0mdebug[0m] [0m          logger.debug(s"run: patching $debugClass with $debugValue")[0m
[0m[[0mdebug[0m] [0m          monkeyPatchField(debugField, debugValue)[0m
[0m[[0mdebug[0m] [0m          isPatched = true[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m      }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m      // Add an assertion here in case the class location changes, so the tests fail...[0m
[0m[[0mdebug[0m] [0m      if (!isPatched) {[0m
[0m[[0mdebug[0m] [0m        throw new IllegalStateException("No debug classes found!")[0m
[0m[[0mdebug[0m] [0m      }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m      // Switch out the args (for certpath loggers that AREN'T static and final)[0m
[0m[[0mdebug[0m] [0m      // This will result in those classes using the base Debug class which will write to System.out, but[0m
[0m[[0mdebug[0m] [0m      // I don't know how to switch out the Debug.getInstance method itself without using a java agent.[0m
[0m[[0mdebug[0m] [0m      val argsField = debugType.getDeclaredField("args")[0m
[0m[[0mdebug[0m] [0m      monkeyPatchField(argsField, newOptions)[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def apply(newOptions: String) {[0m
[0m[[0mdebug[0m] [0m    logger.debug(s"apply: newOptions = ${newOptions}")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    try {[0m
[0m[[0mdebug[0m] [0m      val action = new MonkeyPatchInternalSslDebugAction(newOptions)[0m
[0m[[0mdebug[0m] [0m      AccessController.doPrivileged(action)[0m
[0m[[0mdebug[0m] [0m    } catch {[0m
[0m[[0mdebug[0m] [0m      case NonFatal(e) =>[0m
[0m[[0mdebug[0m] [0m        throw new IllegalStateException("InternalDebug configuration error", e)[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mModified text of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/debug/FixInternalDebugLogging.scala is:[0m
[0m[[0mdebug[0m] [0mNone[0m
[0m[[0mdebug[0m] [0mAbout to create/update header for /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/debug/FixCertpathDebugLogging.scala[0m
[0m[[0mdebug[0m] [0mFirst line of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/debug/FixCertpathDebugLogging.scala is:[0m
[0m[[0mdebug[0m] [0mText of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/debug/FixCertpathDebugLogging.scala is:[0m
[0m[[0mdebug[0m] [0m/*[0m
[0m[[0mdebug[0m] [0m * Copyright (C) 2015 Typesafe Inc. <http://www.typesafe.com>[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mpackage com.typesafe.sslconfig.ssl.debug[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport java.security.AccessController[0m
[0m[[0mdebug[0m] [0mimport com.typesafe.sslconfig.util.{ LoggerFactory, NoDepsLogger }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport scala.util.control.NonFatal[0m
[0m[[0mdebug[0m] [0mimport sun.security.util.Debug[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * This singleton object turns on "certpath" debug logging (originally based off the "java.security.debug" debug flag),[0m
[0m[[0mdebug[0m] [0m * and swaps out references to internal Sun JSSE classes to ensure that the new debug logging settings are honored, and[0m
[0m[[0mdebug[0m] [0m * that debugging can be turned on dynamically, even after static class block initialization has been completed.  It[0m
[0m[[0mdebug[0m] [0m * does this using some {{sun.misc.Unsafe}} black magic.[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * Note that currently the only functionality is to turn debug output ON, with the assumption that all output will[0m
[0m[[0mdebug[0m] [0m * go to an appropriately configured logger that can ignore calls to it.  There is no "off" method.[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0mclass FixCertpathDebugLogging(mkLogger: LoggerFactory) {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  val logger = mkLogger("com.typesafe.sslconfig.ssl.debug.FixCertpathDebugLogging")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  class MonkeyPatchSunSecurityUtilDebugAction(val newDebug: Debug, val newOptions: String) extends FixLoggingAction {[0m
[0m[[0mdebug[0m] [0m    val logger = mkLogger("com.typesafe.sslconfig.ssl.debug.FixCertpathDebugLogging.MonkeyPatchSunSecurityUtilDebugAction")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val initialResource = "/sun/security/provider/certpath/Builder.class"[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    val debugType = classOf[Debug][0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    /**[0m
[0m[[0mdebug[0m] [0m     * Returns true if this class has an instance of {{Debug.getInstance("certpath")}}, false otherwise.[0m
[0m[[0mdebug[0m] [0m     *[0m
[0m[[0mdebug[0m] [0m     * @param className the name of the class.[0m
[0m[[0mdebug[0m] [0m     * @return true if this class should be returned in the set of findClasses, false otherwise.[0m
[0m[[0mdebug[0m] [0m     */[0m
[0m[[0mdebug[0m] [0m    def isValidClass(className: String): Boolean = {[0m
[0m[[0mdebug[0m] [0m      if (className.startsWith("java.security.cert")) return true[0m
[0m[[0mdebug[0m] [0m      if (className.startsWith("sun.security.provider.certpath")) return true[0m
[0m[[0mdebug[0m] [0m      if (className.equals("sun.security.x509.InhibitAnyPolicyExtension")) return true[0m
[0m[[0mdebug[0m] [0m      false[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    /**[0m
[0m[[0mdebug[0m] [0m     * Returns true if the new options contains certpath, false otherwise.  If it does not contain certpath,[0m
[0m[[0mdebug[0m] [0m     * then set the fields to null (which will disable logging).[0m
[0m[[0mdebug[0m] [0m     *[0m
[0m[[0mdebug[0m] [0m     * @return[0m
[0m[[0mdebug[0m] [0m     */[0m
[0m[[0mdebug[0m] [0m    def isUsingDebug: Boolean = (newOptions != null) && newOptions.contains("certpath")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    def run() {[0m
[0m[[0mdebug[0m] [0m      System.setProperty("java.security.debug", newOptions)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m      logger.debug(s"run: debugType = $debugType")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m      val debugValue = if (isUsingDebug) newDebug else null[0m
[0m[[0mdebug[0m] [0m      var isPatched = false[0m
[0m[[0mdebug[0m] [0m      for {[0m
[0m[[0mdebug[0m] [0m        debugClass <- findClasses[0m
[0m[[0mdebug[0m] [0m        debugField <- debugClass.getDeclaredFields[0m
[0m[[0mdebug[0m] [0m      } {[0m
[0m[[0mdebug[0m] [0m        if (isValidField(debugField, debugType)) {[0m
[0m[[0mdebug[0m] [0m          logger.debug(s"run: Patching $debugClass with $debugValue")[0m
[0m[[0mdebug[0m] [0m          monkeyPatchField(debugField, debugValue)[0m
[0m[[0mdebug[0m] [0m          isPatched = true[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m      }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m      // Add an assertion here in case the class location changes, so the tests fail...[0m
[0m[[0mdebug[0m] [0m      if (!isPatched) {[0m
[0m[[0mdebug[0m] [0m        throw new IllegalStateException("No debug classes found!")[0m
[0m[[0mdebug[0m] [0m      }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m      // Switch out the args (for certpath loggers that AREN'T static and final)[0m
[0m[[0mdebug[0m] [0m      // This will result in those classes using the base Debug class which will write to System.out, but[0m
[0m[[0mdebug[0m] [0m      // I don't know how to switch out the Debug.getInstance method itself without using a java agent.[0m
[0m[[0mdebug[0m] [0m      val argsField = debugType.getDeclaredField("args")[0m
[0m[[0mdebug[0m] [0m      monkeyPatchField(argsField, newOptions)[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Extends {{sun.security.util.Debug}} to delegate println to a logger.[0m
[0m[[0mdebug[0m] [0m   *[0m
[0m[[0mdebug[0m] [0m   * @param logger the logger which will receive debug calls.[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  class SunSecurityUtilDebugLogger(logger: NoDepsLogger) extends sun.security.util.Debug {[0m
[0m[[0mdebug[0m] [0m    override def println(message: String) {[0m
[0m[[0mdebug[0m] [0m      if (logger.isDebugEnabled) {[0m
[0m[[0mdebug[0m] [0m        logger.debug(message)[0m
[0m[[0mdebug[0m] [0m      }[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    override def println() {[0m
[0m[[0mdebug[0m] [0m      if (logger.isDebugEnabled) {[0m
[0m[[0mdebug[0m] [0m        logger.debug("")[0m
[0m[[0mdebug[0m] [0m      }[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def apply(newOptions: String, debugOption: Option[Debug] = None) {[0m
[0m[[0mdebug[0m] [0m    logger.debug(s"apply: newOptions = $newOptions, debugOption = $debugOption")[0m
[0m[[0mdebug[0m] [0m    try {[0m
[0m[[0mdebug[0m] [0m      val newDebug = debugOption match {[0m
[0m[[0mdebug[0m] [0m        case Some(d) => d[0m
[0m[[0mdebug[0m] [0m        case None    => new Debug()[0m
[0m[[0mdebug[0m] [0m      }[0m
[0m[[0mdebug[0m] [0m      val action = new MonkeyPatchSunSecurityUtilDebugAction(newDebug, newOptions)[0m
[0m[[0mdebug[0m] [0m      AccessController.doPrivileged(action)[0m
[0m[[0mdebug[0m] [0m    } catch {[0m
[0m[[0mdebug[0m] [0m      case NonFatal(e) =>[0m
[0m[[0mdebug[0m] [0m        throw new IllegalStateException("CertificateDebug configuration error", e)[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mModified text of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/debug/FixCertpathDebugLogging.scala is:[0m
[0m[[0mdebug[0m] [0mNone[0m
[0m[[0mdebug[0m] [0mAbout to create/update header for /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/debug/DebugConfiguration.scala[0m
[0m[[0mdebug[0m] [0mFirst line of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/debug/DebugConfiguration.scala is:[0m
[0m[[0mdebug[0m] [0mText of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/debug/DebugConfiguration.scala is:[0m
[0m[[0mdebug[0m] [0m/*[0m
[0m[[0mdebug[0m] [0m * Copyright (C) 2015 Typesafe Inc. <http://www.typesafe.com>[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mpackage com.typesafe.sslconfig.ssl.debug[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport com.typesafe.sslconfig.ssl.{ JavaSecurityDebugBuilder, JavaxNetDebugBuilder, SSLDebugConfig }[0m
[0m[[0mdebug[0m] [0mimport com.typesafe.sslconfig.util.LoggerFactory[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mclass DebugConfiguration(mkLogger: LoggerFactory) {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  private val logger = mkLogger(getClass)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def configure(d: SSLDebugConfig) {[0m
[0m[[0mdebug[0m] [0m    configureJavaxNetDebug(d)[0m
[0m[[0mdebug[0m] [0m    configureJavaSecurityDebug(d)[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def configureJavaxNetDebug(d: SSLDebugConfig) {[0m
[0m[[0mdebug[0m] [0m    val netDebugOptions = new JavaxNetDebugBuilder(d).build()[0m
[0m[[0mdebug[0m] [0m    logger.debug(s"configureJavaxNetDebug: d = $d, netDebugOptions = $netDebugOptions")[0m
[0m[[0mdebug[0m] [0m    new FixInternalDebugLogging(mkLogger).apply(netDebugOptions)[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def configureJavaSecurityDebug(d: SSLDebugConfig) {[0m
[0m[[0mdebug[0m] [0m    val securityOptions = new JavaSecurityDebugBuilder(d).build()[0m
[0m[[0mdebug[0m] [0m    logger.debug(s"configureJavaSecurityDebug: d = $d, securityOptions = $securityOptions")[0m
[0m[[0mdebug[0m] [0m    System.setProperty("java.security.debug", securityOptions)[0m
[0m[[0mdebug[0m] [0m    new FixCertpathDebugLogging(mkLogger).apply(securityOptions)[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mModified text of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/debug/DebugConfiguration.scala is:[0m
[0m[[0mdebug[0m] [0mNone[0m
[0m[[0mdebug[0m] [0mAbout to create/update header for /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/debug/FixLoggingAction.scala[0m
[0m[[0mdebug[0m] [0mFirst line of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/debug/FixLoggingAction.scala is:[0m
[0m[[0mdebug[0m] [0mText of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/debug/FixLoggingAction.scala is:[0m
[0m[[0mdebug[0m] [0m/*[0m
[0m[[0mdebug[0m] [0m * Copyright (C) 2015 Typesafe Inc. <http://www.typesafe.com>[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mpackage com.typesafe.sslconfig.ssl.debug[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport java.lang.reflect.Field[0m
[0m[[0mdebug[0m] [0mimport java.security.PrivilegedExceptionAction[0m
[0m[[0mdebug[0m] [0mimport com.typesafe.sslconfig.ssl.MonkeyPatcher[0m
[0m[[0mdebug[0m] [0mimport com.typesafe.sslconfig.util.LoggerFactory[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * A privileged action that will find relevant classes containing static final fields of type T and replace[0m
[0m[[0mdebug[0m] [0m * them with the object referenced by {{newDebug}}, and switch out the "args" field value with the value defined[0m
[0m[[0mdebug[0m] [0m * in {{newOptions}}.  This is the only way to change JSSE debugging after the class loads.[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0mabstract class FixLoggingAction extends PrivilegedExceptionAction[Unit] with MonkeyPatcher with ClassFinder {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def newOptions: String[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def isValidField(field: Field, definedType: Class[_]): Boolean = {[0m
[0m[[0mdebug[0m] [0m    import java.lang.reflect.Modifier._[0m
[0m[[0mdebug[0m] [0m    val modifiers: Int = field.getModifiers[0m
[0m[[0mdebug[0m] [0m    field.getType == definedType && isStatic(modifiers)[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mModified text of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/ssl/debug/FixLoggingAction.scala is:[0m
[0m[[0mdebug[0m] [0mNone[0m
[0m[[0mdebug[0m] [0mAbout to create/update header for /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/util/NoDepsLogger.scala[0m
[0m[[0mdebug[0m] [0mFirst line of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/util/NoDepsLogger.scala is:[0m
[0m[[0mdebug[0m] [0mText of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/util/NoDepsLogger.scala is:[0m
[0m[[0mdebug[0m] [0m/*[0m
[0m[[0mdebug[0m] [0m * Copyright (C) 2015 Typesafe Inc. <http://www.typesafe.com>[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mpackage com.typesafe.sslconfig.util[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * Simple logger interface in order to keep the core of this library zero-dependencies.[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0mabstract class NoDepsLogger {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def isDebugEnabled: Boolean[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def debug(msg: String): Unit[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def info(msg: String): Unit[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def warn(msg: String): Unit[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def error(msg: String): Unit[0m
[0m[[0mdebug[0m] [0m  def error(msg: String, throwable: Throwable): Unit[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mobject NoopLogger {[0m
[0m[[0mdebug[0m] [0m  private val _noop = new NoopLogger[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def factory(): LoggerFactory = new LoggerFactory {[0m
[0m[[0mdebug[0m] [0m    override def apply(clazz: Class[_]) = _noop[0m
[0m[[0mdebug[0m] [0m    override def apply(name: String) = _noop[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mfinal class NoopLogger extends NoDepsLogger {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  override def debug(msg: String): Unit = ()[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  override def info(msg: String): Unit = ()[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  override def warn(msg: String): Unit = ()[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  override def error(msg: String): Unit = ()[0m
[0m[[0mdebug[0m] [0m  override def error(msg: String, throwable: Throwable): Unit = ()[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  override def isDebugEnabled: Boolean = false[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mobject PrintlnLogger {[0m
[0m[[0mdebug[0m] [0m  def factory(): LoggerFactory = new LoggerFactory {[0m
[0m[[0mdebug[0m] [0m    override def apply(clazz: Class[_]) = new PrintlnLogger(clazz.getName)[0m
[0m[[0mdebug[0m] [0m    override def apply(name: String) = new PrintlnLogger(name)[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mfinal class PrintlnLogger(name: String) extends NoDepsLogger {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  override def debug(msg: String): Unit = println(s"[DEBUG][$name] $msg")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  override def info(msg: String): Unit = println(s"[INFO][$name] $msg")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  override def warn(msg: String): Unit = println(s"[WARN][$name] $msg")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  override def error(msg: String): Unit = println(s"[ERROR][$name] $msg")[0m
[0m[[0mdebug[0m] [0m  override def error(msg: String, throwable: Throwable): Unit = println(s"[ERROR][$name] $msg")[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  override def isDebugEnabled: Boolean = true[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mModified text of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/util/NoDepsLogger.scala is:[0m
[0m[[0mdebug[0m] [0mNone[0m
[0m[[0mdebug[0m] [0mAbout to create/update header for /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/util/LoggerFactory.scala[0m
[0m[[0mdebug[0m] [0mFirst line of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/util/LoggerFactory.scala is:[0m
[0m[[0mdebug[0m] [0mText of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/util/LoggerFactory.scala is:[0m
[0m[[0mdebug[0m] [0m/*[0m
[0m[[0mdebug[0m] [0m * Copyright (C) 2015 Typesafe Inc. <http://www.typesafe.com>[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mpackage com.typesafe.sslconfig.util[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mtrait LoggerFactory {[0m
[0m[[0mdebug[0m] [0m  def apply(clazz: Class[_]): NoDepsLogger[0m
[0m[[0mdebug[0m] [0m  def apply(name: String): NoDepsLogger[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mModified text of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/util/LoggerFactory.scala is:[0m
[0m[[0mdebug[0m] [0mNone[0m
[0m[[0mdebug[0m] [0mAbout to create/update header for /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/util/Configuration.scala[0m
[0m[[0mdebug[0m] [0mFirst line of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/util/Configuration.scala is:[0m
[0m[[0mdebug[0m] [0mText of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/util/Configuration.scala is:[0m
[0m[[0mdebug[0m] [0m/*[0m
[0m[[0mdebug[0m] [0m * Copyright (C) 2015 Typesafe Inc. <http://www.typesafe.com>[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mpackage com.typesafe.sslconfig.util[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport java.util.concurrent.TimeUnit[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport com.typesafe.config._[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport scala.collection.JavaConverters._[0m
[0m[[0mdebug[0m] [0mimport scala.collection.immutable[0m
[0m[[0mdebug[0m] [0mimport scala.concurrent.duration.FiniteDuration[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/** Based on PlayConfig, adds some helper methods over underlying Config. */[0m
[0m[[0mdebug[0m] [0mclass EnrichedConfig(val underlying: Config) {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Get the config at the given path.[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def get[A](path: String)(implicit loader: ConfigLoader[A]): A = {[0m
[0m[[0mdebug[0m] [0m    loader.load(underlying, path)[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def getSeq[A](path: String)(implicit loader: ConfigLoader[immutable.Seq[A]]): immutable.Seq[A] = {[0m
[0m[[0mdebug[0m] [0m    loader.load(underlying, path)[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Get an optional configuration item.[0m
[0m[[0mdebug[0m] [0m   *[0m
[0m[[0mdebug[0m] [0m   * If the value of the item is null, this will return None, otherwise returns Some.[0m
[0m[[0mdebug[0m] [0m   *[0m
[0m[[0mdebug[0m] [0m   * @throws com.typesafe.config.ConfigException.Missing if the value is undefined (as opposed to null) this will still[0m
[0m[[0mdebug[0m] [0m   *         throw an exception.[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def getOptional[A: ConfigLoader](path: String): Option[A] = {[0m
[0m[[0mdebug[0m] [0m    try {[0m
[0m[[0mdebug[0m] [0m      Option(get(path))[0m
[0m[[0mdebug[0m] [0m    } catch {[0m
[0m[[0mdebug[0m] [0m      case e: ConfigException.Missing => None[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Get a prototyped sequence of objects.[0m
[0m[[0mdebug[0m] [0m   *[0m
[0m[[0mdebug[0m] [0m   * Each object in the sequence will fallback to the object loaded from prototype.$path.[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def getPrototypedSeq(path: String, prototypePath: String = "prototype.$path"): immutable.Seq[EnrichedConfig] = {[0m
[0m[[0mdebug[0m] [0m    val prototype = underlying.getConfig(prototypePath.replace("$path", path))[0m
[0m[[0mdebug[0m] [0m    get[Seq[Config]](path).map { config =>[0m
[0m[[0mdebug[0m] [0m      new EnrichedConfig(config.withFallback(prototype))[0m
[0m[[0mdebug[0m] [0m    }.toList[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Get a prototyped map of objects.[0m
[0m[[0mdebug[0m] [0m   *[0m
[0m[[0mdebug[0m] [0m   * Each value in the map will fallback to the object loaded from prototype.$path.[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def getPrototypedMap(path: String, prototypePath: String = "prototype.$path"): Map[String, EnrichedConfig] = {[0m
[0m[[0mdebug[0m] [0m    val prototype = if (prototypePath.isEmpty) {[0m
[0m[[0mdebug[0m] [0m      underlying[0m
[0m[[0mdebug[0m] [0m    } else {[0m
[0m[[0mdebug[0m] [0m      underlying.getConfig(prototypePath.replace("$path", path))[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m    get[Map[String, Config]](path).map {[0m
[0m[[0mdebug[0m] [0m      case (key, config) => key -> new EnrichedConfig(config.withFallback(prototype))[0m
[0m[[0mdebug[0m] [0m    }.toMap[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Get an optional deprecated configuration item.[0m
[0m[[0mdebug[0m] [0m   *[0m
[0m[[0mdebug[0m] [0m   * If the deprecated configuration item is defined, it will be returned, and a warning will be logged.[0m
[0m[[0mdebug[0m] [0m   *[0m
[0m[[0mdebug[0m] [0m   * Otherwise, the configuration from path will be looked up.[0m
[0m[[0mdebug[0m] [0m   *[0m
[0m[[0mdebug[0m] [0m   * If the value of the item is null, this will return None, otherwise returns Some.[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def getOptionalDeprecated[A: ConfigLoader](path: String, deprecated: String): Option[A] = {[0m
[0m[[0mdebug[0m] [0m    if (underlying.hasPath(deprecated)) {[0m
[0m[[0mdebug[0m] [0m      reportDeprecation(path, deprecated)[0m
[0m[[0mdebug[0m] [0m      getOptional[A](deprecated)[0m
[0m[[0mdebug[0m] [0m    } else {[0m
[0m[[0mdebug[0m] [0m      getOptional[A](path)[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Get a deprecated configuration item.[0m
[0m[[0mdebug[0m] [0m   *[0m
[0m[[0mdebug[0m] [0m   * If the deprecated configuration item is defined, it will be returned, and a warning will be logged.[0m
[0m[[0mdebug[0m] [0m   *[0m
[0m[[0mdebug[0m] [0m   * Otherwise, the configuration from path will be looked up.[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def getDeprecated[A: ConfigLoader](path: String, deprecated: String): A = {[0m
[0m[[0mdebug[0m] [0m    if (underlying.hasPath(deprecated)) {[0m
[0m[[0mdebug[0m] [0m      reportDeprecation(path, deprecated)[0m
[0m[[0mdebug[0m] [0m      get[A](deprecated)[0m
[0m[[0mdebug[0m] [0m    } else {[0m
[0m[[0mdebug[0m] [0m      get[A](path)[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Get a deprecated configuration.[0m
[0m[[0mdebug[0m] [0m   *[0m
[0m[[0mdebug[0m] [0m   * If the deprecated configuration is defined, it will be returned, falling back to the new configuration, and a[0m
[0m[[0mdebug[0m] [0m   * warning will be logged.[0m
[0m[[0mdebug[0m] [0m   *[0m
[0m[[0mdebug[0m] [0m   * Otherwise, the configuration from path will be looked up and used as is.[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def getDeprecatedWithFallback(path: String, deprecated: String, parent: String = ""): EnrichedConfig = {[0m
[0m[[0mdebug[0m] [0m    val config = get[Config](path)[0m
[0m[[0mdebug[0m] [0m    val merged = if (underlying.hasPath(deprecated)) {[0m
[0m[[0mdebug[0m] [0m      reportDeprecation(path, deprecated)[0m
[0m[[0mdebug[0m] [0m      get[Config](deprecated).withFallback(config)[0m
[0m[[0mdebug[0m] [0m    } else config[0m
[0m[[0mdebug[0m] [0m    new EnrichedConfig(merged)[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Creates a configuration error for a specific configuration key.[0m
[0m[[0mdebug[0m] [0m   *[0m
[0m[[0mdebug[0m] [0m   * For example:[0m
[0m[[0mdebug[0m] [0m   * {{{[0m
[0m[[0mdebug[0m] [0m   * val configuration = Configuration.load()[0m
[0m[[0mdebug[0m] [0m   * throw configuration.reportError("engine.connectionUrl", "Cannot connect!")[0m
[0m[[0mdebug[0m] [0m   * }}}[0m
[0m[[0mdebug[0m] [0m   *[0m
[0m[[0mdebug[0m] [0m   * @param path the configuration key, related to this error[0m
[0m[[0mdebug[0m] [0m   * @param message the error message[0m
[0m[[0mdebug[0m] [0m   * @param e the related exception[0m
[0m[[0mdebug[0m] [0m   * @return a configuration exception[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def reportError(path: String, message: String, e: Option[Throwable] = None) = {[0m
[0m[[0mdebug[0m] [0m    //Configuration.configError(if (underlying.hasPath(path)) underlying.getValue(path).origin else underlying.root.origin, message, e)[0m
[0m[[0mdebug[0m] [0m    e.get[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  /**[0m
[0m[[0mdebug[0m] [0m   * Get the immediate subkeys of this configuration.[0m
[0m[[0mdebug[0m] [0m   */[0m
[0m[[0mdebug[0m] [0m  def subKeys: Set[String] = underlying.root().keySet().asScala.toSet[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def reportDeprecation(path: String, deprecated: String): Unit = {[0m
[0m[[0mdebug[0m] [0m    val origin = underlying.getValue(deprecated).origin[0m
[0m[[0mdebug[0m] [0m    //Logger.warn(s"${origin.description}: $deprecated is deprecated, use $path instead")[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mobject EnrichedConfig {[0m
[0m[[0mdebug[0m] [0m  def apply(underlying: Config) = new EnrichedConfig(underlying)[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * A config loader[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0mtrait ConfigLoader[A] { self =>[0m
[0m[[0mdebug[0m] [0m  def load(config: Config, path: String): A[0m
[0m[[0mdebug[0m] [0m  def map[B](f: A => B): ConfigLoader[B] = new ConfigLoader[B] {[0m
[0m[[0mdebug[0m] [0m    def load(config: Config, path: String): B = {[0m
[0m[[0mdebug[0m] [0m      f(self.load(config, path))[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mobject ConfigLoader {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  def apply[A](f: Config => String => A): ConfigLoader[A] = new ConfigLoader[A] {[0m
[0m[[0mdebug[0m] [0m    def load(config: Config, path: String): A = f(config)(path)[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  import scala.collection.JavaConverters._[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  private def toScala[A](as: java.util.List[A]): immutable.Seq[A] = as.asScala.toVector[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  implicit val stringLoader = ConfigLoader(_.getString)[0m
[0m[[0mdebug[0m] [0m  implicit val seqStringLoader = ConfigLoader(_.getStringList).map(toScala)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  implicit val intLoader = ConfigLoader(_.getInt)[0m
[0m[[0mdebug[0m] [0m  implicit val seqIntLoader = ConfigLoader(_.getIntList).map(toScala(_).map(_.toInt))[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  implicit val booleanLoader = ConfigLoader(_.getBoolean)[0m
[0m[[0mdebug[0m] [0m  implicit val seqBooleanLoader = ConfigLoader(_.getBooleanList).map(toScala(_).map(_.booleanValue()))[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  implicit val finiteDurationLoader: ConfigLoader[FiniteDuration] = ConfigLoader(config => config.getDuration(_, TimeUnit.MILLISECONDS))[0m
[0m[[0mdebug[0m] [0m    .map(millis => FiniteDuration(millis, TimeUnit.MILLISECONDS))[0m
[0m[[0mdebug[0m] [0m  implicit val seqFiniteDurationLoader: ConfigLoader[Seq[FiniteDuration]] = ConfigLoader(config => config.getDurationList(_, TimeUnit.MILLISECONDS))[0m
[0m[[0mdebug[0m] [0m    .map(toScala(_).map(millis => FiniteDuration(millis, TimeUnit.MILLISECONDS)))[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  implicit val doubleLoader = ConfigLoader(_.getDouble)[0m
[0m[[0mdebug[0m] [0m  implicit val seqDoubleLoader = ConfigLoader(_.getDoubleList).map(toScala)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  implicit val longLoader = ConfigLoader(_.getLong)[0m
[0m[[0mdebug[0m] [0m  implicit val seqLongLoader = ConfigLoader(_.getLongList).map(toScala)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  implicit val configLoader: ConfigLoader[Config] = ConfigLoader(_.getConfig)[0m
[0m[[0mdebug[0m] [0m  implicit val seqConfigLoader: ConfigLoader[Seq[Config]] = ConfigLoader(_.getConfigList).map(_.asScala)[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  implicit val playConfigLoader = configLoader.map(new EnrichedConfig(_))[0m
[0m[[0mdebug[0m] [0m  implicit val seqEnrichedConfigLoader = seqConfigLoader.map(_.map(new EnrichedConfig(_)))[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  implicit def mapLoader[A](implicit valueLoader: ConfigLoader[A]): ConfigLoader[Map[String, A]] = new ConfigLoader[Map[String, A]] {[0m
[0m[[0mdebug[0m] [0m    def load(config: Config, path: String): Map[String, A] = {[0m
[0m[[0mdebug[0m] [0m      val obj = config.getObject(path)[0m
[0m[[0mdebug[0m] [0m      val conf = obj.toConfig[0m
[0m[[0mdebug[0m] [0m      obj.keySet().asScala.map { key =>[0m
[0m[[0mdebug[0m] [0m        key -> valueLoader.load(conf, key)[0m
[0m[[0mdebug[0m] [0m      }.toMap[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mModified text of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/scala/com/typesafe/sslconfig/util/Configuration.scala is:[0m
[0m[[0mdebug[0m] [0mNone[0m
[0m[[0mdebug[0m] [0mAbout to create/update header for /Users/ktoso/code/ssl-config/ssl-config-core/src/main/java/com/typesafe/sslconfig/Base64.java[0m
[0m[[0mdebug[0m] [0mFirst line of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/java/com/typesafe/sslconfig/Base64.java is:[0m
[0m[[0mdebug[0m] [0mText of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/java/com/typesafe/sslconfig/Base64.java is:[0m
[0m[[0mdebug[0m] [0m/*[0m
[0m[[0mdebug[0m] [0m * Copyright (C) 2015 Typesafe Inc. <http://www.typesafe.com>[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mpackage com.typesafe.sslconfig;[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0mimport java.util.Arrays;[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m/**[0m
[0m[[0mdebug[0m] [0m * A very fast and memory efficient class to encode and decode to and from BASE64 in full accordance[0m
[0m[[0mdebug[0m] [0m * with RFC 2045.<br><br>[0m
[0m[[0mdebug[0m] [0m * On Windows XP sp1 with 1.4.2_04 and later ;), this encoder and decoder is about 10 times faster[0m
[0m[[0mdebug[0m] [0m * on small arrays (10 - 1000 bytes) and 2-3 times as fast on larger arrays (10000 - 1000000 bytes)[0m
[0m[[0mdebug[0m] [0m * compared to <code>sun.misc.Encoder()/Decoder()</code>.<br><br>[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * On byte arrays the encoder is about 20% faster than Jakarta Commons Base64 Codec for encode and[0m
[0m[[0mdebug[0m] [0m * about 50% faster for decoding large arrays. This implementation is about twice as fast on very small[0m
[0m[[0mdebug[0m] [0m * arrays (&lt 30 bytes). If source/destination is a <code>String</code> this[0m
[0m[[0mdebug[0m] [0m * version is about three times as fast due to the fact that the Commons Codec result has to be recoded[0m
[0m[[0mdebug[0m] [0m * to a <code>String</code> from <code>byte[]</code>, which is very expensive.<br><br>[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * This encode/decode algorithm doesn't create any temporary arrays as many other codecs do, it only[0m
[0m[[0mdebug[0m] [0m * allocates the resulting array. This produces less garbage and it is possible to handle arrays twice[0m
[0m[[0mdebug[0m] [0m * as large as algorithms that create a temporary array. (E.g. Jakarta Commons Codec). It is unknown[0m
[0m[[0mdebug[0m] [0m * whether Sun's <code>sun.misc.Encoder()/Decoder()</code> produce temporary arrays but since performance[0m
[0m[[0mdebug[0m] [0m * is quite low it probably does.<br><br>[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * The encoder produces the same output as the Sun one except that the Sun's encoder appends[0m
[0m[[0mdebug[0m] [0m * a trailing line separator if the last character isn't a pad. Unclear why but it only adds to the[0m
[0m[[0mdebug[0m] [0m * length and is probably a side effect. Both are in conformance with RFC 2045 though.<br>[0m
[0m[[0mdebug[0m] [0m * Commons codec seem to always att a trailing line separator.<br><br>[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * <b>Note!</b>[0m
[0m[[0mdebug[0m] [0m * The encode/decode method pairs (types) come in three versions with the <b>exact</b> same algorithm and[0m
[0m[[0mdebug[0m] [0m * thus a lot of code redundancy. This is to not create any temporary arrays for transcoding to/from different[0m
[0m[[0mdebug[0m] [0m * format types. The methods not used can simply be commented out.<br><br>[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * There is also a "fast" version of all decode methods that works the same way as the normal ones, but[0m
[0m[[0mdebug[0m] [0m * har a few demands on the decoded input. Normally though, these fast verions should be used if the source if[0m
[0m[[0mdebug[0m] [0m * the input is known and it hasn't bee tampered with.<br><br>[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * If you find the code useful or you find a bug, please send me a note at base64 @ miginfocom . com.[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * Licence (BSD):[0m
[0m[[0mdebug[0m] [0m * ==============[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * Copyright (c) 2004, Mikael Grev, MiG InfoCom AB. (base64 @ miginfocom . com)[0m
[0m[[0mdebug[0m] [0m * All rights reserved.[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * Redistribution and use in source and binary forms, with or without modification,[0m
[0m[[0mdebug[0m] [0m * are permitted provided that the following conditions are met:[0m
[0m[[0mdebug[0m] [0m * Redistributions of source code must retain the above copyright notice, this list[0m
[0m[[0mdebug[0m] [0m * of conditions and the following disclaimer.[0m
[0m[[0mdebug[0m] [0m * Redistributions in binary form must reproduce the above copyright notice, this[0m
[0m[[0mdebug[0m] [0m * list of conditions and the following disclaimer in the documentation and/or other[0m
[0m[[0mdebug[0m] [0m * materials provided with the distribution.[0m
[0m[[0mdebug[0m] [0m * Neither the name of the MiG InfoCom AB nor the names of its contributors may be[0m
[0m[[0mdebug[0m] [0m * used to endorse or promote products derived from this software without specific[0m
[0m[[0mdebug[0m] [0m * prior written permission.[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND[0m
[0m[[0mdebug[0m] [0m * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED[0m
[0m[[0mdebug[0m] [0m * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.[0m
[0m[[0mdebug[0m] [0m * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,[0m
[0m[[0mdebug[0m] [0m * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,[0m
[0m[[0mdebug[0m] [0m * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,[0m
[0m[[0mdebug[0m] [0m * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,[0m
[0m[[0mdebug[0m] [0m * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)[0m
[0m[[0mdebug[0m] [0m * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY[0m
[0m[[0mdebug[0m] [0m * OF SUCH DAMAGE.[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * @version 2.2[0m
[0m[[0mdebug[0m] [0m * @author Mikael Grev[0m
[0m[[0mdebug[0m] [0m *         Date: 2004-aug-02[0m
[0m[[0mdebug[0m] [0m *         Time: 11:31:11[0m
[0m[[0mdebug[0m] [0m *[0m
[0m[[0mdebug[0m] [0m * Adapted in 2009 by Mathias Doenitz.[0m
[0m[[0mdebug[0m] [0m */[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m@SuppressWarnings({"UnnecessaryParentheses"})[0m
[0m[[0mdebug[0m] [0mpublic class Base64 {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    // -------- FIELDS -------------------------------------------------------------------------------------------------[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    private static Base64 RFC2045;[0m
[0m[[0mdebug[0m] [0m    private static Base64 CUSTOM;[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    private final char[] CA;[0m
[0m[[0mdebug[0m] [0m    private final int[] IA;[0m
[0m[[0mdebug[0m] [0m    private final char fillChar;[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    // -------- STATIC METHODS -----------------------------------------------------------------------------------------[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    public static Base64 custom() {[0m
[0m[[0mdebug[0m] [0m        if (CUSTOM == null) {[0m
[0m[[0mdebug[0m] [0m            CUSTOM = new Base64("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-_");[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m        return CUSTOM;[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    public static Base64 rfc2045() {[0m
[0m[[0mdebug[0m] [0m        if (RFC2045 == null) {[0m
[0m[[0mdebug[0m] [0m            RFC2045 = new Base64("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=");[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m        return RFC2045;[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    // -------- CONSTRUCTORS -------------------------------------------------------------------------------------------[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    public Base64(String alphabet) {[0m
[0m[[0mdebug[0m] [0m        if (alphabet == null || alphabet.length() != 65) throw new IllegalArgumentException();[0m
[0m[[0mdebug[0m] [0m        CA = alphabet.substring(0, 64).toCharArray();[0m
[0m[[0mdebug[0m] [0m        IA = new int[256];[0m
[0m[[0mdebug[0m] [0m        Arrays.fill(IA, -1);[0m
[0m[[0mdebug[0m] [0m        for (int i = 0, iS = CA.length; i < iS; i++) {[0m
[0m[[0mdebug[0m] [0m            IA[CA[i]] = i;[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m        fillChar = alphabet.charAt(64);[0m
[0m[[0mdebug[0m] [0m        IA[fillChar] = 0;[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    // -------- OTHER METHODS ------------------------------------------------------------------------------------------[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    /**[0m
[0m[[0mdebug[0m] [0m     * Decodes a BASE64 encoded char array. All illegal characters will be ignored and can handle both arrays with[0m
[0m[[0mdebug[0m] [0m     * and without line separators.[0m
[0m[[0mdebug[0m] [0m     *[0m
[0m[[0mdebug[0m] [0m     * @param sArr The source array. <code>null</code> or length 0 will return an empty array.[0m
[0m[[0mdebug[0m] [0m     * @return The decoded array of bytes. May be of length 0. Will be <code>null</code> if the legal characters[0m
[0m[[0mdebug[0m] [0m     *         (including '=') isn't divideable by 4.  (I.e. definitely corrupted).[0m
[0m[[0mdebug[0m] [0m     */[0m
[0m[[0mdebug[0m] [0m    public final byte[] decode(char[] sArr) {[0m
[0m[[0mdebug[0m] [0m        // Check special case[0m
[0m[[0mdebug[0m] [0m        int sLen = sArr != null ? sArr.length : 0;[0m
[0m[[0mdebug[0m] [0m        if (sLen == 0) {[0m
[0m[[0mdebug[0m] [0m            return new byte[0];[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        // Count illegal characters (including '\r', '\n') to know what size the returned array will be,[0m
[0m[[0mdebug[0m] [0m        // so we don't have to reallocate & copy it later.[0m
[0m[[0mdebug[0m] [0m        int sepCnt = 0; // Number of separator characters. (Actually illegal characters, but that's a bonus...)[0m
[0m[[0mdebug[0m] [0m        for ([0m
[0m[[0mdebug[0m] [0m                int i = 0; i <[0m
[0m[[0mdebug[0m] [0m                sLen; i++)  // If input is "pure" (I.e. no line separators or illegal chars) base64 this loop can be commented out.[0m
[0m[[0mdebug[0m] [0m        {[0m
[0m[[0mdebug[0m] [0m            if (IA[sArr[i]] < 0) {[0m
[0m[[0mdebug[0m] [0m                sepCnt++;[0m
[0m[[0mdebug[0m] [0m            }[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        // Check so that legal chars (including '=') are evenly divideable by 4 as specified in RFC 2045.[0m
[0m[[0mdebug[0m] [0m        if ((sLen - sepCnt) % 4 != 0) {[0m
[0m[[0mdebug[0m] [0m            return null;[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        int pad = 0;[0m
[0m[[0mdebug[0m] [0m        for (int i = sLen; i > 1 && IA[sArr[--i]] <= 0;) {[0m
[0m[[0mdebug[0m] [0m            if (sArr[i] == fillChar) {[0m
[0m[[0mdebug[0m] [0m                pad++;[0m
[0m[[0mdebug[0m] [0m            }[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        int len = ((sLen - sepCnt) * 6 >> 3) - pad;[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        byte[] dArr = new byte[len];       // Preallocate byte[] of exact length[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        for (int s = 0, d = 0; d < len;) {[0m
[0m[[0mdebug[0m] [0m            // Assemble three bytes into an int from four "valid" characters.[0m
[0m[[0mdebug[0m] [0m            int i = 0;[0m
[0m[[0mdebug[0m] [0m            for (int j = 0; j < 4; j++) {   // j only increased if a valid char was found.[0m
[0m[[0mdebug[0m] [0m                int c = IA[sArr[s++]];[0m
[0m[[0mdebug[0m] [0m                if (c >= 0) {[0m
[0m[[0mdebug[0m] [0m                    i |= c << (18 - j * 6);[0m
[0m[[0mdebug[0m] [0m                } else {[0m
[0m[[0mdebug[0m] [0m                    j--;[0m
[0m[[0mdebug[0m] [0m                }[0m
[0m[[0mdebug[0m] [0m            }[0m
[0m[[0mdebug[0m] [0m            // Add the bytes[0m
[0m[[0mdebug[0m] [0m            dArr[d++] = (byte) (i >> 16);[0m
[0m[[0mdebug[0m] [0m            if (d < len) {[0m
[0m[[0mdebug[0m] [0m                dArr[d++] = (byte) (i >> 8);[0m
[0m[[0mdebug[0m] [0m                if (d < len) {[0m
[0m[[0mdebug[0m] [0m                    dArr[d++] = (byte) i;[0m
[0m[[0mdebug[0m] [0m                }[0m
[0m[[0mdebug[0m] [0m            }[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m        return dArr;[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    /**[0m
[0m[[0mdebug[0m] [0m     * Decodes a BASE64 encoded byte array. All illegal characters will be ignored and can handle both arrays with[0m
[0m[[0mdebug[0m] [0m     * and without line separators.[0m
[0m[[0mdebug[0m] [0m     *[0m
[0m[[0mdebug[0m] [0m     * @param sArr The source array. Length 0 will return an empty array. <code>null</code> will throw an exception.[0m
[0m[[0mdebug[0m] [0m     * @return The decoded array of bytes. May be of length 0. Will be <code>null</code> if the legal characters[0m
[0m[[0mdebug[0m] [0m     *         (including '=') isn't divideable by 4. (I.e. definitely corrupted).[0m
[0m[[0mdebug[0m] [0m     */[0m
[0m[[0mdebug[0m] [0m    public final byte[] decode(byte[] sArr) {[0m
[0m[[0mdebug[0m] [0m        // Check special case[0m
[0m[[0mdebug[0m] [0m        int sLen = sArr.length;[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        // Count illegal characters (including '\r', '\n') to know what size the returned array will be,[0m
[0m[[0mdebug[0m] [0m        // so we don't have to reallocate & copy it later.[0m
[0m[[0mdebug[0m] [0m        int sepCnt = 0; // Number of separator characters. (Actually illegal characters, but that's a bonus...)[0m
[0m[[0mdebug[0m] [0m        for ([0m
[0m[[0mdebug[0m] [0m                int i = 0; i <[0m
[0m[[0mdebug[0m] [0m                sLen; i++)      // If input is "pure" (I.e. no line separators or illegal chars) base64 this loop can be commented out.[0m
[0m[[0mdebug[0m] [0m        {[0m
[0m[[0mdebug[0m] [0m            if (IA[sArr[i] & 0xff] < 0) {[0m
[0m[[0mdebug[0m] [0m                sepCnt++;[0m
[0m[[0mdebug[0m] [0m            }[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        // Check so that legal chars (including '=') are evenly divideable by 4 as specified in RFC 2045.[0m
[0m[[0mdebug[0m] [0m        if ((sLen - sepCnt) % 4 != 0) {[0m
[0m[[0mdebug[0m] [0m            return null;[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        int pad = 0;[0m
[0m[[0mdebug[0m] [0m        for (int i = sLen; i > 1 && IA[sArr[--i] & 0xff] <= 0;) {[0m
[0m[[0mdebug[0m] [0m            if (sArr[i] == fillChar) {[0m
[0m[[0mdebug[0m] [0m                pad++;[0m
[0m[[0mdebug[0m] [0m            }[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        int len = ((sLen - sepCnt) * 6 >> 3) - pad;[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        byte[] dArr = new byte[len];       // Preallocate byte[] of exact length[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        for (int s = 0, d = 0; d < len;) {[0m
[0m[[0mdebug[0m] [0m            // Assemble three bytes into an int from four "valid" characters.[0m
[0m[[0mdebug[0m] [0m            int i = 0;[0m
[0m[[0mdebug[0m] [0m            for (int j = 0; j < 4; j++) {   // j only increased if a valid char was found.[0m
[0m[[0mdebug[0m] [0m                int c = IA[sArr[s++] & 0xff];[0m
[0m[[0mdebug[0m] [0m                if (c >= 0) {[0m
[0m[[0mdebug[0m] [0m                    i |= c << (18 - j * 6);[0m
[0m[[0mdebug[0m] [0m                } else {[0m
[0m[[0mdebug[0m] [0m                    j--;[0m
[0m[[0mdebug[0m] [0m                }[0m
[0m[[0mdebug[0m] [0m            }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m            // Add the bytes[0m
[0m[[0mdebug[0m] [0m            dArr[d++] = (byte) (i >> 16);[0m
[0m[[0mdebug[0m] [0m            if (d < len) {[0m
[0m[[0mdebug[0m] [0m                dArr[d++] = (byte) (i >> 8);[0m
[0m[[0mdebug[0m] [0m                if (d < len) {[0m
[0m[[0mdebug[0m] [0m                    dArr[d++] = (byte) i;[0m
[0m[[0mdebug[0m] [0m                }[0m
[0m[[0mdebug[0m] [0m            }[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        return dArr;[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    /**[0m
[0m[[0mdebug[0m] [0m     * Decodes a BASE64 encoded <code>String</code>. All illegal characters will be ignored and can handle both strings with[0m
[0m[[0mdebug[0m] [0m     * and without line separators.<br>[0m
[0m[[0mdebug[0m] [0m     * <b>Note!</b> It can be up to about 2x the speed to call <code>decode(str.toCharArray())</code> instead. That[0m
[0m[[0mdebug[0m] [0m     * will create a temporary array though. This version will use <code>str.charAt(i)</code> to iterate the string.[0m
[0m[[0mdebug[0m] [0m     *[0m
[0m[[0mdebug[0m] [0m     * @param str The source string. <code>null</code> or length 0 will return an empty array.[0m
[0m[[0mdebug[0m] [0m     * @return The decoded array of bytes. May be of length 0. Will be <code>null</code> if the legal characters[0m
[0m[[0mdebug[0m] [0m     *         (including '=') isn't divideable by 4.  (I.e. definitely corrupted).[0m
[0m[[0mdebug[0m] [0m     */[0m
[0m[[0mdebug[0m] [0m    public final byte[] decode(String str) {[0m
[0m[[0mdebug[0m] [0m        // Check special case[0m
[0m[[0mdebug[0m] [0m        int sLen = str != null ? str.length() : 0;[0m
[0m[[0mdebug[0m] [0m        if (sLen == 0) {[0m
[0m[[0mdebug[0m] [0m            return new byte[0];[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        // Count illegal characters (including '\r', '\n') to know what size the returned array will be,[0m
[0m[[0mdebug[0m] [0m        // so we don't have to reallocate & copy it later.[0m
[0m[[0mdebug[0m] [0m        int sepCnt = 0; // Number of separator characters. (Actually illegal characters, but that's a bonus...)[0m
[0m[[0mdebug[0m] [0m        for ([0m
[0m[[0mdebug[0m] [0m                int i = 0; i <[0m
[0m[[0mdebug[0m] [0m                sLen; i++)  // If input is "pure" (I.e. no line separators or illegal chars) base64 this loop can be commented out.[0m
[0m[[0mdebug[0m] [0m        {[0m
[0m[[0mdebug[0m] [0m            if (IA[str.charAt(i)] < 0) {[0m
[0m[[0mdebug[0m] [0m                sepCnt++;[0m
[0m[[0mdebug[0m] [0m            }[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        // Check so that legal chars (including '=') are evenly divideable by 4 as specified in RFC 2045.[0m
[0m[[0mdebug[0m] [0m        if ((sLen - sepCnt) % 4 != 0) {[0m
[0m[[0mdebug[0m] [0m            return null;[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        // Count '=' at end[0m
[0m[[0mdebug[0m] [0m        int pad = 0;[0m
[0m[[0mdebug[0m] [0m        for (int i = sLen; i > 1 && IA[str.charAt(--i)] <= 0;) {[0m
[0m[[0mdebug[0m] [0m            if (str.charAt(i) == fillChar) {[0m
[0m[[0mdebug[0m] [0m                pad++;[0m
[0m[[0mdebug[0m] [0m            }[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        int len = ((sLen - sepCnt) * 6 >> 3) - pad;[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        byte[] dArr = new byte[len];       // Preallocate byte[] of exact length[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        for (int s = 0, d = 0; d < len;) {[0m
[0m[[0mdebug[0m] [0m            // Assemble three bytes into an int from four "valid" characters.[0m
[0m[[0mdebug[0m] [0m            int i = 0;[0m
[0m[[0mdebug[0m] [0m            for (int j = 0; j < 4; j++) {   // j only increased if a valid char was found.[0m
[0m[[0mdebug[0m] [0m                int c = IA[str.charAt(s++)];[0m
[0m[[0mdebug[0m] [0m                if (c >= 0) {[0m
[0m[[0mdebug[0m] [0m                    i |= c << (18 - j * 6);[0m
[0m[[0mdebug[0m] [0m                } else {[0m
[0m[[0mdebug[0m] [0m                    j--;[0m
[0m[[0mdebug[0m] [0m                }[0m
[0m[[0mdebug[0m] [0m            }[0m
[0m[[0mdebug[0m] [0m            // Add the bytes[0m
[0m[[0mdebug[0m] [0m            dArr[d++] = (byte) (i >> 16);[0m
[0m[[0mdebug[0m] [0m            if (d < len) {[0m
[0m[[0mdebug[0m] [0m                dArr[d++] = (byte) (i >> 8);[0m
[0m[[0mdebug[0m] [0m                if (d < len) {[0m
[0m[[0mdebug[0m] [0m                    dArr[d++] = (byte) i;[0m
[0m[[0mdebug[0m] [0m                }[0m
[0m[[0mdebug[0m] [0m            }[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m        return dArr;[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    /**[0m
[0m[[0mdebug[0m] [0m     * Decodes a BASE64 encoded char array that is known to be resonably well formatted. The method is about twice as[0m
[0m[[0mdebug[0m] [0m     * fast as {@link #decode(char[])}. The preconditions are:<br>[0m
[0m[[0mdebug[0m] [0m     * + The array must have a line length of 76 chars OR no line separators at all (one line).<br>[0m
[0m[[0mdebug[0m] [0m     * + Line separator must be "\r\n", as specified in RFC 2045[0m
[0m[[0mdebug[0m] [0m     * + The array must not contain illegal characters within the encoded string<br>[0m
[0m[[0mdebug[0m] [0m     * + The array CAN have illegal characters at the beginning and end, those will be dealt with appropriately.<br>[0m
[0m[[0mdebug[0m] [0m     *[0m
[0m[[0mdebug[0m] [0m     * @param sArr The source array. Length 0 will return an empty array. <code>null</code> will throw an exception.[0m
[0m[[0mdebug[0m] [0m     * @return The decoded array of bytes. May be of length 0.[0m
[0m[[0mdebug[0m] [0m     */[0m
[0m[[0mdebug[0m] [0m    public final byte[] decodeFast(char[] sArr) {[0m
[0m[[0mdebug[0m] [0m        // Check special case[0m
[0m[[0mdebug[0m] [0m        int sLen = sArr.length;[0m
[0m[[0mdebug[0m] [0m        if (sLen == 0) {[0m
[0m[[0mdebug[0m] [0m            return new byte[0];[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        int sIx = 0, eIx = sLen - 1;    // Start and end index after trimming.[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        // Trim illegal chars from start[0m
[0m[[0mdebug[0m] [0m        while (sIx < eIx && IA[sArr[sIx]] < 0) {[0m
[0m[[0mdebug[0m] [0m            sIx++;[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        // Trim illegal chars from end[0m
[0m[[0mdebug[0m] [0m        while (eIx > 0 && IA[sArr[eIx]] < 0) {[0m
[0m[[0mdebug[0m] [0m            eIx--;[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        // get the padding count (=) (0, 1 or 2)[0m
[0m[[0mdebug[0m] [0m        int pad = sArr[eIx] == fillChar ? (sArr[eIx - 1] == fillChar ? 2 : 1) : 0;  // Count '=' at end.[0m
[0m[[0mdebug[0m] [0m        int cCnt = eIx - sIx + 1;   // Content count including possible separators[0m
[0m[[0mdebug[0m] [0m        int sepCnt = sLen > 76 ? (sArr[76] == '\r' ? cCnt / 78 : 0) << 1 : 0;[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        int len = ((cCnt - sepCnt) * 6 >> 3) - pad; // The number of decoded bytes[0m
[0m[[0mdebug[0m] [0m        byte[] dArr = new byte[len];       // Preallocate byte[] of exact length[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        // Decode all but the last 0 - 2 bytes.[0m
[0m[[0mdebug[0m] [0m        int d = 0;[0m
[0m[[0mdebug[0m] [0m        for (int cc = 0, eLen = (len / 3) * 3; d < eLen;) {[0m
[0m[[0mdebug[0m] [0m            // Assemble three bytes into an int from four "valid" characters.[0m
[0m[[0mdebug[0m] [0m            int i = IA[sArr[sIx++]] << 18 | IA[sArr[sIx++]] << 12 | IA[sArr[sIx++]] << 6 | IA[sArr[sIx++]];[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m            // Add the bytes[0m
[0m[[0mdebug[0m] [0m            dArr[d++] = (byte) (i >> 16);[0m
[0m[[0mdebug[0m] [0m            dArr[d++] = (byte) (i >> 8);[0m
[0m[[0mdebug[0m] [0m            dArr[d++] = (byte) i;[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m            // If line separator, jump over it.[0m
[0m[[0mdebug[0m] [0m            if (sepCnt > 0 && ++cc == 19) {[0m
[0m[[0mdebug[0m] [0m                sIx += 2;[0m
[0m[[0mdebug[0m] [0m                cc = 0;[0m
[0m[[0mdebug[0m] [0m            }[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        if (d < len) {[0m
[0m[[0mdebug[0m] [0m            // Decode last 1-3 bytes (incl '=') into 1-3 bytes[0m
[0m[[0mdebug[0m] [0m            int i = 0;[0m
[0m[[0mdebug[0m] [0m            for (int j = 0; sIx <= eIx - pad; j++) {[0m
[0m[[0mdebug[0m] [0m                i |= IA[sArr[sIx++]] << (18 - j * 6);[0m
[0m[[0mdebug[0m] [0m            }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m            for (int r = 16; d < len; r -= 8) {[0m
[0m[[0mdebug[0m] [0m                dArr[d++] = (byte) (i >> r);[0m
[0m[[0mdebug[0m] [0m            }[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        return dArr;[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    /**[0m
[0m[[0mdebug[0m] [0m     * Decodes a BASE64 encoded byte array that is known to be resonably well formatted. The method is about twice as[0m
[0m[[0mdebug[0m] [0m     * fast as {@link #decode(byte[])}. The preconditions are:<br>[0m
[0m[[0mdebug[0m] [0m     * + The array must have a line length of 76 chars OR no line separators at all (one line).<br>[0m
[0m[[0mdebug[0m] [0m     * + Line separator must be "\r\n", as specified in RFC 2045[0m
[0m[[0mdebug[0m] [0m     * + The array must not contain illegal characters within the encoded string<br>[0m
[0m[[0mdebug[0m] [0m     * + The array CAN have illegal characters at the beginning and end, those will be dealt with appropriately.<br>[0m
[0m[[0mdebug[0m] [0m     *[0m
[0m[[0mdebug[0m] [0m     * @param sArr The source array. Length 0 will return an empty array. <code>null</code> will throw an exception.[0m
[0m[[0mdebug[0m] [0m     * @return The decoded array of bytes. May be of length 0.[0m
[0m[[0mdebug[0m] [0m     */[0m
[0m[[0mdebug[0m] [0m    public final byte[] decodeFast(byte[] sArr) {[0m
[0m[[0mdebug[0m] [0m        // Check special case[0m
[0m[[0mdebug[0m] [0m        int sLen = sArr.length;[0m
[0m[[0mdebug[0m] [0m        if (sLen == 0) {[0m
[0m[[0mdebug[0m] [0m            return new byte[0];[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        int sIx = 0, eIx = sLen - 1;    // Start and end index after trimming.[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        // Trim illegal chars from start[0m
[0m[[0mdebug[0m] [0m        while (sIx < eIx && IA[sArr[sIx] & 0xff] < 0) {[0m
[0m[[0mdebug[0m] [0m            sIx++;[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        // Trim illegal chars from end[0m
[0m[[0mdebug[0m] [0m        while (eIx > 0 && IA[sArr[eIx] & 0xff] < 0) {[0m
[0m[[0mdebug[0m] [0m            eIx--;[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        // get the padding count (=) (0, 1 or 2)[0m
[0m[[0mdebug[0m] [0m        int pad = sArr[eIx] == fillChar ? (sArr[eIx - 1] == fillChar ? 2 : 1) : 0;  // Count '=' at end.[0m
[0m[[0mdebug[0m] [0m        int cCnt = eIx - sIx + 1;   // Content count including possible separators[0m
[0m[[0mdebug[0m] [0m        int sepCnt = sLen > 76 ? (sArr[76] == '\r' ? cCnt / 78 : 0) << 1 : 0;[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        int len = ((cCnt - sepCnt) * 6 >> 3) - pad; // The number of decoded bytes[0m
[0m[[0mdebug[0m] [0m        byte[] dArr = new byte[len];       // Preallocate byte[] of exact length[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        // Decode all but the last 0 - 2 bytes.[0m
[0m[[0mdebug[0m] [0m        int d = 0;[0m
[0m[[0mdebug[0m] [0m        for (int cc = 0, eLen = (len / 3) * 3; d < eLen;) {[0m
[0m[[0mdebug[0m] [0m            // Assemble three bytes into an int from four "valid" characters.[0m
[0m[[0mdebug[0m] [0m            int i = IA[sArr[sIx++]] << 18 | IA[sArr[sIx++]] << 12 | IA[sArr[sIx++]] << 6 | IA[sArr[sIx++]];[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m            // Add the bytes[0m
[0m[[0mdebug[0m] [0m            dArr[d++] = (byte) (i >> 16);[0m
[0m[[0mdebug[0m] [0m            dArr[d++] = (byte) (i >> 8);[0m
[0m[[0mdebug[0m] [0m            dArr[d++] = (byte) i;[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m            // If line separator, jump over it.[0m
[0m[[0mdebug[0m] [0m            if (sepCnt > 0 && ++cc == 19) {[0m
[0m[[0mdebug[0m] [0m                sIx += 2;[0m
[0m[[0mdebug[0m] [0m                cc = 0;[0m
[0m[[0mdebug[0m] [0m            }[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        if (d < len) {[0m
[0m[[0mdebug[0m] [0m            // Decode last 1-3 bytes (incl '=') into 1-3 bytes[0m
[0m[[0mdebug[0m] [0m            int i = 0;[0m
[0m[[0mdebug[0m] [0m            for (int j = 0; sIx <= eIx - pad; j++) {[0m
[0m[[0mdebug[0m] [0m                i |= IA[sArr[sIx++]] << (18 - j * 6);[0m
[0m[[0mdebug[0m] [0m            }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m            for (int r = 16; d < len; r -= 8) {[0m
[0m[[0mdebug[0m] [0m                dArr[d++] = (byte) (i >> r);[0m
[0m[[0mdebug[0m] [0m            }[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        return dArr;[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    /**[0m
[0m[[0mdebug[0m] [0m     * Decodes a BASE64 encoded string that is known to be resonably well formatted. The method is about twice as[0m
[0m[[0mdebug[0m] [0m     * fast as {@link #decode(String)}. The preconditions are:<br>[0m
[0m[[0mdebug[0m] [0m     * + The array must have a line length of 76 chars OR no line separators at all (one line).<br>[0m
[0m[[0mdebug[0m] [0m     * + Line separator must be "\r\n", as specified in RFC 2045[0m
[0m[[0mdebug[0m] [0m     * + The array must not contain illegal characters within the encoded string<br>[0m
[0m[[0mdebug[0m] [0m     * + The array CAN have illegal characters at the beginning and end, those will be dealt with appropriately.<br>[0m
[0m[[0mdebug[0m] [0m     *[0m
[0m[[0mdebug[0m] [0m     * @param s The source string. Length 0 will return an empty array. <code>null</code> will throw an exception.[0m
[0m[[0mdebug[0m] [0m     * @return The decoded array of bytes. May be of length 0.[0m
[0m[[0mdebug[0m] [0m     */[0m
[0m[[0mdebug[0m] [0m    public final byte[] decodeFast(String s) {[0m
[0m[[0mdebug[0m] [0m        // Check special case[0m
[0m[[0mdebug[0m] [0m        int sLen = s.length();[0m
[0m[[0mdebug[0m] [0m        if (sLen == 0) {[0m
[0m[[0mdebug[0m] [0m            return new byte[0];[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        int sIx = 0, eIx = sLen - 1;    // Start and end index after trimming.[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        // Trim illegal chars from start[0m
[0m[[0mdebug[0m] [0m        while (sIx < eIx && IA[s.charAt(sIx) & 0xff] < 0) {[0m
[0m[[0mdebug[0m] [0m            sIx++;[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        // Trim illegal chars from end[0m
[0m[[0mdebug[0m] [0m        while (eIx > 0 && IA[s.charAt(eIx) & 0xff] < 0) {[0m
[0m[[0mdebug[0m] [0m            eIx--;[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        // get the padding count (=) (0, 1 or 2)[0m
[0m[[0mdebug[0m] [0m        int pad = s.charAt(eIx) == fillChar ? (s.charAt(eIx - 1) == fillChar ? 2 : 1) : 0;  // Count '=' at end.[0m
[0m[[0mdebug[0m] [0m        int cCnt = eIx - sIx + 1;   // Content count including possible separators[0m
[0m[[0mdebug[0m] [0m        int sepCnt = sLen > 76 ? (s.charAt(76) == '\r' ? cCnt / 78 : 0) << 1 : 0;[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        int len = ((cCnt - sepCnt) * 6 >> 3) - pad; // The number of decoded bytes[0m
[0m[[0mdebug[0m] [0m        byte[] dArr = new byte[len];       // Preallocate byte[] of exact length[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        // Decode all but the last 0 - 2 bytes.[0m
[0m[[0mdebug[0m] [0m        int d = 0;[0m
[0m[[0mdebug[0m] [0m        for (int cc = 0, eLen = (len / 3) * 3; d < eLen;) {[0m
[0m[[0mdebug[0m] [0m            // Assemble three bytes into an int from four "valid" characters.[0m
[0m[[0mdebug[0m] [0m            int i = IA[s.charAt(sIx++)] << 18 | IA[s.charAt(sIx++)] << 12 | IA[s.charAt(sIx++)] << 6 | IA[s[0m
[0m[[0mdebug[0m] [0m                    .charAt(sIx++)];[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m            // Add the bytes[0m
[0m[[0mdebug[0m] [0m            dArr[d++] = (byte) (i >> 16);[0m
[0m[[0mdebug[0m] [0m            dArr[d++] = (byte) (i >> 8);[0m
[0m[[0mdebug[0m] [0m            dArr[d++] = (byte) i;[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m            // If line separator, jump over it.[0m
[0m[[0mdebug[0m] [0m            if (sepCnt > 0 && ++cc == 19) {[0m
[0m[[0mdebug[0m] [0m                sIx += 2;[0m
[0m[[0mdebug[0m] [0m                cc = 0;[0m
[0m[[0mdebug[0m] [0m            }[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        if (d < len) {[0m
[0m[[0mdebug[0m] [0m            // Decode last 1-3 bytes (incl '=') into 1-3 bytes[0m
[0m[[0mdebug[0m] [0m            int i = 0;[0m
[0m[[0mdebug[0m] [0m            for (int j = 0; sIx <= eIx - pad; j++) {[0m
[0m[[0mdebug[0m] [0m                i |= IA[s.charAt(sIx++)] << (18 - j * 6);[0m
[0m[[0mdebug[0m] [0m            }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m            for (int r = 16; d < len; r -= 8) {[0m
[0m[[0mdebug[0m] [0m                dArr[d++] = (byte) (i >> r);[0m
[0m[[0mdebug[0m] [0m            }[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        return dArr;[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    // ****************************************************************************************[0m
[0m[[0mdebug[0m] [0m    // *  byte[] version[0m
[0m[[0mdebug[0m] [0m    // ****************************************************************************************[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    /**[0m
[0m[[0mdebug[0m] [0m     * Encodes a raw byte array into a BASE64 <code>byte[]</code> representation i accordance with RFC 2045.[0m
[0m[[0mdebug[0m] [0m     *[0m
[0m[[0mdebug[0m] [0m     * @param sArr    The bytes to convert. If <code>null</code> or length 0 an empty array will be returned.[0m
[0m[[0mdebug[0m] [0m     * @param lineSep Optional "\r\n" after 76 characters, unless end of file.<br>[0m
[0m[[0mdebug[0m] [0m     *                No line separator will be in breach of RFC 2045 which specifies max 76 per line but will be a[0m
[0m[[0mdebug[0m] [0m     *                little faster.[0m
[0m[[0mdebug[0m] [0m     * @return A BASE64 encoded array. Never <code>null</code>.[0m
[0m[[0mdebug[0m] [0m     */[0m
[0m[[0mdebug[0m] [0m    public final byte[] encodeToByte(byte[] sArr, boolean lineSep) {[0m
[0m[[0mdebug[0m] [0m        // Check special case[0m
[0m[[0mdebug[0m] [0m        int sLen = sArr != null ? sArr.length : 0;[0m
[0m[[0mdebug[0m] [0m        if (sLen == 0) {[0m
[0m[[0mdebug[0m] [0m            return new byte[0];[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        int eLen = (sLen / 3) * 3;                              // Length of even 24-bits.[0m
[0m[[0mdebug[0m] [0m        int cCnt = ((sLen - 1) / 3 + 1) << 2;                   // Returned character count[0m
[0m[[0mdebug[0m] [0m        int dLen = cCnt + (lineSep ? (cCnt - 1) / 76 << 1 : 0); // Length of returned array[0m
[0m[[0mdebug[0m] [0m        byte[] dArr = new byte[dLen];[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        // Encode even 24-bits[0m
[0m[[0mdebug[0m] [0m        for (int s = 0, d = 0, cc = 0; s < eLen;) {[0m
[0m[[0mdebug[0m] [0m            // Copy next three bytes into lower 24 bits of int, paying attension to sign.[0m
[0m[[0mdebug[0m] [0m            int i = (sArr[s++] & 0xff) << 16 | (sArr[s++] & 0xff) << 8 | (sArr[s++] & 0xff);[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m            // Encode the int into four chars[0m
[0m[[0mdebug[0m] [0m            dArr[d++] = (byte) CA[(i >>> 18) & 0x3f];[0m
[0m[[0mdebug[0m] [0m            dArr[d++] = (byte) CA[(i >>> 12) & 0x3f];[0m
[0m[[0mdebug[0m] [0m            dArr[d++] = (byte) CA[(i >>> 6) & 0x3f];[0m
[0m[[0mdebug[0m] [0m            dArr[d++] = (byte) CA[i & 0x3f];[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m            // Add optional line separator[0m
[0m[[0mdebug[0m] [0m            if (lineSep && ++cc == 19 && d < dLen - 2) {[0m
[0m[[0mdebug[0m] [0m                dArr[d++] = '\r';[0m
[0m[[0mdebug[0m] [0m                dArr[d++] = '\n';[0m
[0m[[0mdebug[0m] [0m                cc = 0;[0m
[0m[[0mdebug[0m] [0m            }[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        // Pad and encode last bits if source isn't an even 24 bits.[0m
[0m[[0mdebug[0m] [0m        int left = sLen - eLen; // 0 - 2.[0m
[0m[[0mdebug[0m] [0m        if (left > 0) {[0m
[0m[[0mdebug[0m] [0m            // Prepare the int[0m
[0m[[0mdebug[0m] [0m            int i = ((sArr[eLen] & 0xff) << 10) | (left == 2 ? ((sArr[sLen - 1] & 0xff) << 2) : 0);[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m            // Set last four chars[0m
[0m[[0mdebug[0m] [0m            dArr[dLen - 4] = (byte) CA[i >> 12];[0m
[0m[[0mdebug[0m] [0m            dArr[dLen - 3] = (byte) CA[(i >>> 6) & 0x3f];[0m
[0m[[0mdebug[0m] [0m            dArr[dLen - 2] = left == 2 ? (byte) CA[i & 0x3f] : (byte) fillChar;[0m
[0m[[0mdebug[0m] [0m            dArr[dLen - 1] = (byte) fillChar;[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m        return dArr;[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    // ****************************************************************************************[0m
[0m[[0mdebug[0m] [0m    // * String version[0m
[0m[[0mdebug[0m] [0m    // ****************************************************************************************[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    /**[0m
[0m[[0mdebug[0m] [0m     * Encodes a raw byte array into a BASE64 <code>String</code> representation in accordance with RFC 2045.[0m
[0m[[0mdebug[0m] [0m     *[0m
[0m[[0mdebug[0m] [0m     * @param sArr    The bytes to convert. If <code>null</code> or length 0 an empty array will be returned.[0m
[0m[[0mdebug[0m] [0m     * @param lineSep Optional "\r\n" after 76 characters, unless end of file.<br>[0m
[0m[[0mdebug[0m] [0m     *                No line separator will be in breach of RFC 2045 which specifies max 76 per line but will be a[0m
[0m[[0mdebug[0m] [0m     *                little faster.[0m
[0m[[0mdebug[0m] [0m     * @return A BASE64 encoded array. Never <code>null</code>.[0m
[0m[[0mdebug[0m] [0m     */[0m
[0m[[0mdebug[0m] [0m    public final String encodeToString(byte[] sArr, boolean lineSep) {[0m
[0m[[0mdebug[0m] [0m        // Reuse char[] since we can't create a String incrementally anyway and StringBuffer/Builder would be slower.[0m
[0m[[0mdebug[0m] [0m        return new String(encodeToChar(sArr, lineSep));[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    // ****************************************************************************************[0m
[0m[[0mdebug[0m] [0m    // *  char[] version[0m
[0m[[0mdebug[0m] [0m    // ****************************************************************************************[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    /**[0m
[0m[[0mdebug[0m] [0m     * Encodes a raw byte array into a BASE64 <code>char[]</code> representation i accordance with RFC 2045.[0m
[0m[[0mdebug[0m] [0m     *[0m
[0m[[0mdebug[0m] [0m     * @param sArr    The bytes to convert. If <code>null</code> or length 0 an empty array will be returned.[0m
[0m[[0mdebug[0m] [0m     * @param lineSep Optional "\r\n" after 76 characters, unless end of file.<br>[0m
[0m[[0mdebug[0m] [0m     *                No line separator will be in breach of RFC 2045 which specifies max 76 per line but will be a[0m
[0m[[0mdebug[0m] [0m     *                little faster.[0m
[0m[[0mdebug[0m] [0m     * @return A BASE64 encoded array. Never <code>null</code>.[0m
[0m[[0mdebug[0m] [0m     */[0m
[0m[[0mdebug[0m] [0m    public final char[] encodeToChar(byte[] sArr, boolean lineSep) {[0m
[0m[[0mdebug[0m] [0m        // Check special case[0m
[0m[[0mdebug[0m] [0m        int sLen = sArr != null ? sArr.length : 0;[0m
[0m[[0mdebug[0m] [0m        if (sLen == 0) {[0m
[0m[[0mdebug[0m] [0m            return new char[0];[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        int eLen = (sLen / 3) * 3;              // Length of even 24-bits.[0m
[0m[[0mdebug[0m] [0m        int cCnt = ((sLen - 1) / 3 + 1) << 2;   // Returned character count[0m
[0m[[0mdebug[0m] [0m        int dLen = cCnt + (lineSep ? (cCnt - 1) / 76 << 1 : 0); // Length of returned array[0m
[0m[[0mdebug[0m] [0m        char[] dArr = new char[dLen];[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        // Encode even 24-bits[0m
[0m[[0mdebug[0m] [0m        for (int s = 0, d = 0, cc = 0; s < eLen;) {[0m
[0m[[0mdebug[0m] [0m            // Copy next three bytes into lower 24 bits of int, paying attension to sign.[0m
[0m[[0mdebug[0m] [0m            int i = (sArr[s++] & 0xff) << 16 | (sArr[s++] & 0xff) << 8 | (sArr[s++] & 0xff);[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m            // Encode the int into four chars[0m
[0m[[0mdebug[0m] [0m            dArr[d++] = CA[(i >>> 18) & 0x3f];[0m
[0m[[0mdebug[0m] [0m            dArr[d++] = CA[(i >>> 12) & 0x3f];[0m
[0m[[0mdebug[0m] [0m            dArr[d++] = CA[(i >>> 6) & 0x3f];[0m
[0m[[0mdebug[0m] [0m            dArr[d++] = CA[i & 0x3f];[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m            // Add optional line separator[0m
[0m[[0mdebug[0m] [0m            if (lineSep && ++cc == 19 && d < dLen - 2) {[0m
[0m[[0mdebug[0m] [0m                dArr[d++] = '\r';[0m
[0m[[0mdebug[0m] [0m                dArr[d++] = '\n';[0m
[0m[[0mdebug[0m] [0m                cc = 0;[0m
[0m[[0mdebug[0m] [0m            }[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m        // Pad and encode last bits if source isn't even 24 bits.[0m
[0m[[0mdebug[0m] [0m        int left = sLen - eLen; // 0 - 2.[0m
[0m[[0mdebug[0m] [0m        if (left > 0) {[0m
[0m[[0mdebug[0m] [0m            // Prepare the int[0m
[0m[[0mdebug[0m] [0m            int i = ((sArr[eLen] & 0xff) << 10) | (left == 2 ? ((sArr[sLen - 1] & 0xff) << 2) : 0);[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m            // Set last four chars[0m
[0m[[0mdebug[0m] [0m            dArr[dLen - 4] = CA[i >> 12];[0m
[0m[[0mdebug[0m] [0m            dArr[dLen - 3] = CA[(i >>> 6) & 0x3f];[0m
[0m[[0mdebug[0m] [0m            dArr[dLen - 2] = left == 2 ? CA[i & 0x3f] : fillChar;[0m
[0m[[0mdebug[0m] [0m            dArr[dLen - 1] = fillChar;[0m
[0m[[0mdebug[0m] [0m        }[0m
[0m[[0mdebug[0m] [0m        return dArr;[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    public char[] getAlphabet() {[0m
[0m[[0mdebug[0m] [0m        return CA;[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mModified text of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/java/com/typesafe/sslconfig/Base64.java is:[0m
[0m[[0mdebug[0m] [0mNone[0m
[0m[[0mdebug[0m] [0mAbout to create/update header for /Users/ktoso/code/ssl-config/ssl-config-core/src/main/resources/reference.conf[0m
[0m[[0mdebug[0m] [0mFirst line of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/resources/reference.conf is:[0m
[0m[[0mdebug[0m] [0mText of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/resources/reference.conf is:[0m
[0m[[0mdebug[0m] [0m# Copyright (C) 2015 Typesafe Inc. <http://www.typesafe.com>[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m# ssl configuration[0m
[0m[[0mdebug[0m] [0mssl-config {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  logger = "com.typesafe.sslconfig.util.NoopLogger"[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  # Whether we should use the default JVM SSL configuration or not[0m
[0m[[0mdebug[0m] [0m  # When false additional configuration will be applied on the context (as configured in ssl-config).[0m
[0m[[0mdebug[0m] [0m  default = false[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  # The ssl protocol to use[0m
[0m[[0mdebug[0m] [0m  protocol = "TLSv1.2"[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  # Whether revocation lists should be checked, if null, defaults to platform default setting.[0m
[0m[[0mdebug[0m] [0m  checkRevocation = null[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  # A sequence of URLs for obtaining revocation lists[0m
[0m[[0mdebug[0m] [0m  revocationLists = [][0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  # The enabled cipher suites. If empty, uses the platform default.[0m
[0m[[0mdebug[0m] [0m  enabledCipherSuites = [][0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  # The enabled protocols. If empty, uses the platform default.[0m
[0m[[0mdebug[0m] [0m  enabledProtocols = ["TLSv1.2", "TLSv1.1", "TLSv1"][0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  # The disabled signature algorithms[0m
[0m[[0mdebug[0m] [0m  disabledSignatureAlgorithms = ["MD2", "MD4", "MD5"][0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  # The disabled key algorithms[0m
[0m[[0mdebug[0m] [0m  disabledKeyAlgorithms = ["RSA keySize < 2048", "DSA keySize < 2048", "EC keySize < 224"][0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  # The debug configuration[0m
[0m[[0mdebug[0m] [0m  debug = [][0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  # The hostname verifier class.[0m
[0m[[0mdebug[0m] [0m  # If non null, should be the fully qualify classname of a class that imlpements HostnameVerifier,[0m
[0m[[0mdebug[0m] [0m  # otherwise the default will be used[0m
[0m[[0mdebug[0m] [0m  hostnameVerifierClass = null[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  sslParameters {[0m
[0m[[0mdebug[0m] [0m    # translates to a setNeedClientAuth / setWantClientAuth calls[0m
[0m[[0mdebug[0m] [0m    # "default" â€“ leaves the (which for JDK8 means wantClientAuth and needClientAuth are set to false.)[0m
[0m[[0mdebug[0m] [0m    # "none"    â€“ `setNeedClientAuth(false)`[0m
[0m[[0mdebug[0m] [0m    # "want"    â€“ `setWantClientAuth(true)`[0m
[0m[[0mdebug[0m] [0m    # "need"    â€“ `setNeedClientAuth(true)`[0m
[0m[[0mdebug[0m] [0m    clientAuth = "default"[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    # protocols (names)[0m
[0m[[0mdebug[0m] [0m    protocols = [][0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  # Configuration for the key manager[0m
[0m[[0mdebug[0m] [0m  keyManager {[0m
[0m[[0mdebug[0m] [0m    # The key manager algorithm. If empty, uses the platform default.[0m
[0m[[0mdebug[0m] [0m    algorithm = null[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    # The key stores[0m
[0m[[0mdebug[0m] [0m    stores = [[0m
[0m[[0mdebug[0m] [0m    ][0m
[0m[[0mdebug[0m] [0m    # The key stores should look like this[0m
[0m[[0mdebug[0m] [0m    prototype.stores {[0m
[0m[[0mdebug[0m] [0m      # The store type. If null, defaults to the platform default store type, ie JKS.[0m
[0m[[0mdebug[0m] [0m      type = null[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m      # The path to the keystore file. Either this must be non null, or data must be non null.[0m
[0m[[0mdebug[0m] [0m      path = null[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m      # The data for the keystore. Either this must be non null, or path must be non null.[0m
[0m[[0mdebug[0m] [0m      data = null[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m      # The password for loading the keystore. If null, uses no password.[0m
[0m[[0mdebug[0m] [0m      password = null[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  trustManager {[0m
[0m[[0mdebug[0m] [0m    # The trust manager algorithm. If empty, uses the platform default.[0m
[0m[[0mdebug[0m] [0m    algorithm = null[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    # The trust stores[0m
[0m[[0mdebug[0m] [0m    stores = [[0m
[0m[[0mdebug[0m] [0m    ][0m
[0m[[0mdebug[0m] [0m    # The key stores should look like this[0m
[0m[[0mdebug[0m] [0m    prototype.stores {[0m
[0m[[0mdebug[0m] [0m      # The store type. If null, defaults to the platform default store type, ie JKS.[0m
[0m[[0mdebug[0m] [0m      type = null[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m      # The path to the keystore file. Either this must be non null, or data must be non null.[0m
[0m[[0mdebug[0m] [0m      path = null[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m      # The data for the keystore. Either this must be non null, or path must be non null.[0m
[0m[[0mdebug[0m] [0m      data = null[0m
[0m[[0mdebug[0m] [0m    }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  # The loose ssl options.  These allow configuring ssl to be more loose about what it accepts,[0m
[0m[[0mdebug[0m] [0m  # at the cost of introducing potential security issues.[0m
[0m[[0mdebug[0m] [0m  loose {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    # Whether weak protocols should be allowed[0m
[0m[[0mdebug[0m] [0m    allowWeakProtocols = false[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    # Whether weak ciphers should be allowed[0m
[0m[[0mdebug[0m] [0m    allowWeakCiphers = false[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    # If non null, overrides the platform default for whether legacy hello messsages should be allowed.[0m
[0m[[0mdebug[0m] [0m    allowLegacyHelloMessages = null[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    # If non null, overrides the platform defalut for whether unsafe renegotiation should be allowed.[0m
[0m[[0mdebug[0m] [0m    allowUnsafeRenegotiation = null[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    # Whether hostname verification should be disabled[0m
[0m[[0mdebug[0m] [0m    disableHostnameVerification = false[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    # Whether the SNI (Server Name Indication) TLS extension should be disabled[0m
[0m[[0mdebug[0m] [0m    # This setting MAY be respected by client libraries.[0m
[0m[[0mdebug[0m] [0m    #[0m
[0m[[0mdebug[0m] [0m    # https://tools.ietf.org/html/rfc3546#sectiom-3.1[0m
[0m[[0mdebug[0m] [0m    disableSNI = false[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    # Whether any certificate should be accepted or not[0m
[0m[[0mdebug[0m] [0m    acceptAnyCertificate = false[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  # Debug configuration[0m
[0m[[0mdebug[0m] [0m  debug {[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    # Turn on all debugging[0m
[0m[[0mdebug[0m] [0m    all = false[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    # Turn on ssl debugging[0m
[0m[[0mdebug[0m] [0m    ssl = false[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    # Turn certpath debugging on[0m
[0m[[0mdebug[0m] [0m    certpath = false[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    # Turn ocsp debugging on[0m
[0m[[0mdebug[0m] [0m    ocsp = false[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    # Enable per-record tracing[0m
[0m[[0mdebug[0m] [0m    record = false[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    # hex dump of record plaintext, requires record to be true[0m
[0m[[0mdebug[0m] [0m    plaintext = false[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    # print raw SSL/TLS packets, requires record to be true[0m
[0m[[0mdebug[0m] [0m    packet = false[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    # Print each handshake message[0m
[0m[[0mdebug[0m] [0m    handshake = false[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    # Print hex dump of each handshake message, requires handshake to be true[0m
[0m[[0mdebug[0m] [0m    data = false[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    # Enable verbose handshake message printing, requires handshake to be true[0m
[0m[[0mdebug[0m] [0m    verbose = false[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    # Print key generation data[0m
[0m[[0mdebug[0m] [0m    keygen = false[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    # Print session activity[0m
[0m[[0mdebug[0m] [0m    session = false[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    # Print default SSL initialization[0m
[0m[[0mdebug[0m] [0m    defaultctx = false[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    # Print SSLContext tracing[0m
[0m[[0mdebug[0m] [0m    sslctx = false[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    # Print session cache tracing[0m
[0m[[0mdebug[0m] [0m    sessioncache = false[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    # Print key manager tracing[0m
[0m[[0mdebug[0m] [0m    keymanager = false[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    # Print trust manager tracing[0m
[0m[[0mdebug[0m] [0m    trustmanager = false[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m    # Turn pluggability debugging on[0m
[0m[[0mdebug[0m] [0m    pluggability = false[0m
[0m[[0mdebug[0m] [0m[0m
[0m[[0mdebug[0m] [0m  }[0m
[0m[[0mdebug[0m] [0m}[0m
[0m[[0mdebug[0m] [0mModified text of /Users/ktoso/code/ssl-config/ssl-config-core/src/main/resources/reference.conf is:[0m
[0m[[0mdebug[0m] [0mNone[0m
